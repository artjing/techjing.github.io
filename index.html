<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hexo">

  
    <meta property="og:image" content="">
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Hexo</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>Hexo<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Keep and carry on.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2017/06/17/多线程之GCD(下篇/">符号化IOS崩溃日志，解读堆栈信息</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2017-06-17  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="多线程中的——队列和任务"><a href="#多线程中的——队列和任务" class="headerlink" title="多线程中的——队列和任务"></a>多线程中的——队列和任务</h3><p>队列分为串行和并行，对于队列来说，它只负责任务的调度，不负责任务的执行。<br><strong>串行队列：</strong>任务按照顺序调度，执行完前一个任务，下一个任务才会被调度。<br><img src="https://github.com/artjing/BLOGIMAGE/blob/master/%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97.jpg?raw=true" alt=""><br><strong>并行队列：</strong>只要有空闲的线程，当前任务就会被调度，交给线程去执行，而不用考虑前面的任务。<br><img src="https://github.com/artjing/BLOGIMAGE/blob/master/%E5%B9%B6%E8%A1%8C%E9%98%9F%E5%88%97.jpg?raw=true" alt="">  </p>
<p><strong>主队列：</strong>专门用来在主线程调度任务的队列，所以主队列的任务都要在主线程来执行，主队列随着程序的启动一起创建。<br><strong>全局队列：</strong>是为了方便程序开发提供的，与并发队列一样，区别只在于，在MRC下，并发队列需要我们手动释放。 </p>
<p>任务的执行分为同步和异步<br><strong>同步：</strong>不会开启新的线程，任务按顺序执行<br><strong>异步：</strong>会开启新的线程，任务可以并发的执行。<br>当队列和任务组合在一起，就有下面四种组合：<br>串行队列同步执行、串行队列异步执行、并行队列同步执行、并行队列异步执行<br>对于前三种，由于串行是按照顺序执行，而同步不会开启新的线程，所以它们都是一个一个按照顺序执行的，只有并行异步是可以实现任务的并发，并且开启新的线程。</p>
<h3 id="dispatch-sync造成的死锁"><a href="#dispatch-sync造成的死锁" class="headerlink" title="dispatch_sync造成的死锁"></a>dispatch_sync造成的死锁</h3><p>dispatch_sync就是将指定的block同步的追加到指定的Dispatch Queue中，在追加的Block结束之前，dispatch_sync会一直等待。源于这样的情况，dispatch_sync函数也特别容易引起死锁，例如下面三种情况都会造成死锁：</p>
<pre><code>// 在主线程中执行指定的Block，并等待其执行结束。但在主线程中，正执行着这个代码，导致无法追加到dispatch_get_main_queue的Block，而造成死锁。

dispatch_queue_t queue = dispatch_get_main_queue();
dispatch_sync(queue, ^{
    NSLog(@&quot;同步&quot;);
});

dispatch_async(queue, ^{
    dispatch_sync(queue, ^{
        NSLog(@&quot;同步&quot;);
    });
});

dispatch_queue_t queue = dispatch_queue_create(&quot;com.dispatchQueue.forSynDispatch&quot;, NULL);
dispatch_sync(queue, ^{
    NSLog(@&quot;同步&quot;);
});
</code></pre><p>如果我们在控制器中添加了下面的两段代码，可以看到同步和异步的区别： </p>
<pre><code>- (void)viewDidLoad
{
[super viewDidLoad];
// 因为是同步任务，NSLog(@&quot;end&quot;)会一直等待前面的Block执行完再打印。
dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    NSLog(@&quot;blcok1&quot;);
});
    NSLog(@&quot;end&quot;);
  }  

 - (void)viewDidLoad
{
[super viewDidLoad];
// 异步的认为，直接走下下面的打印，在全局队列中完成Block，不需要等待。
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    NSLog(@&quot;blcok1&quot;);
});
    NSLog(@&quot;end&quot;);
}
</code></pre><h3 id="选择使用dispatch-async"><a href="#选择使用dispatch-async" class="headerlink" title="选择使用dispatch_async"></a>选择使用dispatch_async</h3><p>何时可以考虑使用dispatch_async呢：<br>1，自定义串行队列，当我们想串行执行后台任务，并且跟踪它的完成时，使用dispatch_async是一个不错的选择，它可以消除资源竞争，每次该线程只有一个任务在执行。<br>2，主队列，当我们想执行完一个并发任务之后回到主线程更新UI，这是经常会用到的方法，它可以确保这个任务在在当前方法完成后的某个时间点执行。<br>3，并发任务，执行后台并发任务一般会选择。  </p>
<h3 id="使用延迟提高用户体验"><a href="#使用延迟提高用户体验" class="headerlink" title="使用延迟提高用户体验"></a>使用延迟提高用户体验</h3><pre><code>- (void)showOrHideNavPrompt
{
// Implement me!
NSInteger count = [[PhotoManager sharedManager] photos].count;
double delayInsecond = 1.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) delayInsecond * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^{
    if (!count) {
        [self.navigationItem setPrompt:@&quot;先添加图片&quot;];
    }else{
        [self.navigationItem setPrompt:nil];
    }
});
}
</code></pre><h4 id="dispatch-barrier障碍函数"><a href="#dispatch-barrier障碍函数" class="headerlink" title="dispatch_barrier障碍函数"></a>dispatch_barrier障碍函数</h4><p>使用场景：当我们定义了几个并发队列，使用dispatch_barrier障碍函数可以确保它被提交的时间点上是队列上唯一被执行的条目，也就是先于它提交到队列的条目一定能在这个Block执行前完成。当障碍函数的Block执行完成后，再执行并发队列剩下的任务。  </p>
<p><img src="https://github.com/artjing/BLOGIMAGE/blob/master/dispatch_barrer.jpg?raw=true" alt=""> </p>
<h3 id="dispatch-once让单例线程安全"><a href="#dispatch-once让单例线程安全" class="headerlink" title="dispatch_once让单例线程安全"></a>dispatch_once让单例线程安全</h3><p>如果我们自己写了一个对象（比如一个MutableArray）的存取方法，它被多个控制器同时访问。我们想自控制它的竞态，你会怎么做呢？如果你使用if条件判断，实现起来可能稍微麻烦，而且不好控制它的临界区，导致最终我们取到的不是我们想要的结果。对于竞态的重要性，我们可以使用dispatch_once,以县城安全的方式执行且仅执行代码块一次。视图访问临界区的其它线程会被阻塞，直到临界区完成。</p>
<h3 id="dispatch-group调度组"><a href="#dispatch-group调度组" class="headerlink" title="dispatch_group调度组"></a>dispatch_group调度组</h3><p>不管我们的任务是同步还是异步，也不管它们是不是在同一个队列，调度组会在整个任务完成后通知你，我们拿到这个通知进行下面的操作。例如下面的代码，是对原来的处理进行了优化：</p>
<pre><code>- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock
{
__block NSError *error;

dispatch_group_t downloadGroup = dispatch_group_create();

for (NSInteger i = 0; i &lt; 3; i++) {
    NSURL *url;
    switch (i) {
        case 0:
            url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString];
            break;
        case 1:
            url = [NSURL URLWithString:kSuccessKidURLString];
            break;
        case 2:
            url = [NSURL URLWithString:kLotsOfFacesURLString];
            break;
        default:
            break;
    }

    dispatch_group_enter(downloadGroup);
    Photo *photo = [[Photo alloc] initwithURL:url
                          withCompletionBlock:^(UIImage *image, NSError *_error) {
                              if (_error) {
                                  error = _error;
                              }
                              dispatch_group_leave(downloadGroup);
                          }];

    [[PhotoManager sharedManager] addPhoto:photo];
}

dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{
    if (completionBlock) {
        completionBlock(error);
    }
});
}
// 需要注意的是，dispatch_group_enter要跟dispatch_group_leave成对的出现。dispatch_group_enter表示我们手动的通知Dispatch Group任务已经开始，dispatch_group_notify是以异步的方式工作。
</code></pre><h3 id="GCD的实现"><a href="#GCD的实现" class="headerlink" title="GCD的实现"></a>GCD的实现</h3><p>GCD是内核级的（即IOS和OSX的核心是XUN内核），它是基于XUN内核实现的，它的API全部在libdispatch库中。GCD的底层实现主要有Dispatch Queue（用于管理block操作），和Dispatch source（用于处理事件）。</p>
<p>GCD有一个底层线程池，线程中存放着一个个线程，并且这些线程是可以重用的，如果一段时间后这个线程没有被调用，线程就会被销毁。开多少线程是由线程池决定的，不需要我们维护（一般建议线程控制在3-5条）。我们关心的是向队列中添加任务，队列调度即可。<br>如果队列中存放的是异步的任务，当任务出队后，线程池会提供一个线程任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时候，线程池会再次提供一个线程执行第二个任务，执行完再回到底层线程池中。这样就对此线程完成一个服用，而不需要没一个任务执行都开启新的额线程，节约了开销。  </p>
<h4 id="GCD与NSOperationQueue的区别："><a href="#GCD与NSOperationQueue的区别：" class="headerlink" title="GCD与NSOperationQueue的区别："></a>GCD与NSOperationQueue的区别：</h4><p>1，GCD是纯c语言的API，NSOperationQueue是基于GCD的OC版本的封装。<br>2，GCD只支持FIFO的队列，NSOperationQueue可以自己调整执行顺序，可以设置最大并发数量。<br>3，NSOperationQueue支持KVO，可以检测operation是否正在执行，是否结束，是否取消。<br>4，GCD的执行速度比NSOperationQueue快。</p>
<pre><code>- (void)viewDidLoad
{
  [super viewDidLoad];

// 原来的方法
// UIImage *overlayImage = [self faceOverlayImageFromImage:_image];
//[self fadeInNewImage:overlayImage];

// 优化后：viewDidLoad在主线程执行，下面将绘图工作从主线程移到全局队列，Block会被异步的提交，使得viewDidLoad更早的在主线程完成，加载过程感觉起来更快，如果我们加载的是一个超大的图像，应用就不会再加载视图控制上“挂住”。
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
    UIImage *overlayImage = [self faceOverlayImageFromImage:_image];
    dispatch_async(dispatch_get_main_queue(), ^{
        [self fadeInNewImage:overlayImage];
    });
});
}
</code></pre><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>当任务之间有依赖关系或者需要监听任务的执行情况，就选择NSOperationQueue。使用GCD要比使用NSTread这些一般的多线程编程API更好。</p>
<p>Dispatch Queue通过结构体和链表，被实现为FIFO队列，FIFO队列管理是通过dispatch_aync等函数所追加的Block，Block并不是直接加入FIFO队列，而是先加入Dispatch_continuation这一类型结构体中，然后再加入FIFO队列。该Dispatch_continuation用于记忆Block所属的Dispatch Group和其它一些信息，相当于一般常说的执行上下文。</p>

	
	</div>
  <a type="button" href="/2017/06/17/多线程之GCD(下篇/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/10/30/shell打包脚本解读/">shell自动打包脚本解读</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-10-30  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>几年前刚开始接触ios开发的时候，就已经开始用脚本进行自动化打包，但那个时候，只是复制了别人的东西来用，没有深究它其中的原理。我们都知道，shell是一个在开发中经常要用到的脚本，所以决心整理一下脚本相关的东西，一个是熟悉shell的语句，再是可以深入的理解xcode的编译机制。 </p>
<h2 id="xcodebuild-简介"><a href="#xcodebuild-简介" class="headerlink" title="xcodebuild 简介"></a>xcodebuild 简介</h2><p>xcodebuild是苹果提供的打包项目或者工程的命令，通常打包用xcodebuild和xcrun两个命令，xcodebuild负责编译，xcrun负责将app打成ipa。  </p>
<pre><code>/usr/bin/xcodebuild -target targetName clean // 清理工程 
/usr/bin/xcodebuild -target targetName // 编译工程 
xcodebuild -target targetName CODE_SIGN_IDENTITY=&quot;iPhone Distribution:XXX&quot;
xcrun -sdk iphoneos PackageApplication -v .app souce path -o .app to path --sign &quot;iPhone Distribution:XXXXXX&quot;
</code></pre><h2 id="shell脚本之–自动打包"><a href="#shell脚本之–自动打包" class="headerlink" title="shell脚本之–自动打包"></a>shell脚本之–自动打包</h2><pre><code>// shell脚本程序必须以此作为开始
#!/bin/bash 

// set -e的作用是，在它之后出现的代码，只要返回非零，整个脚本立即退出，一般使用这个参数都是出于程序安全性的考虑
set -e

// #后面是注释
#bundleIdentifier 

// xx=&quot;&quot;代码定义一个变量
bundle_id=&quot;com.suning.fanfan&quot;

#appName
app_name=“XXX”

#workspace
work_space=&quot;SecondHand.xcworkspace&quot;

#scheme
scheme=&quot;SecondHand&quot;

// 使用变量时，才用$，${}一般用于连接变量与其它变量或常量等，例如${bundle_id}suning，相当于com.suning.fanfansuning
#xocdebuild pre
xcode_build=&quot;xcodebuild -workspace ${work_space} -scheme ${scheme} -configuration Release&quot;

// $(pwd)是当前目录的全路径名称
#工程绝对路径
project_path=$(pwd)
echo &quot;======工程路径：${project_path}======&quot;

// 创建一个我们用于打包的路径，当前目录后面拼路径及时间区分。$(date +%Y-%m-%d_%H_%M)格式化输出日期，date -d &quot;1 day ago&quot; +&quot;%Y-%m-%d&quot;
#创建保存打包结果的目录
result_path=${project_path}/build/build_test_$(date +%Y-%m-%d_%H_%M)
mkdir -p &quot;${result_path}&quot;
echo &quot;======最终打包路径：${result_path}======&quot;

// ls 的意思是把文件按照类型归类，并且在末尾加上/*等符号标识 
|是管道输出，把前面命令的结果当做输入传给后面的命令 
grep xcodeproj的意思是从中挑出以xcodeproj结尾的行 
awk是一个强大的文本分析工具，它会将文件逐行的读入，以空格为默认的分隔符将每行进行切片，切开的部分再进行各种分析处理。它的语法一般是：awk &apos;{pattern + action}&apos; {filenames}，pattern标识awk在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令
awk -F.xcodeproj &apos;{print $1}在下面的代码中，代笔的意思是，查找.xcodeproj内容，然后以空格分隔，取第一个。
#工程配置文件路径
project_name=$(ls | grep xcodeproj | awk -F.xcodeproj &apos;{print $1}&apos;)
echo &quot;======工程文件名称：${project_name}======&quot;
target_name=${project_name}
echo &quot;======target名称：${target_name}======&quot;
project_infoplist_path=&quot;${project_path}/${project_name}/Info.plist&quot;

echo &quot;======Info.plist路径：${project_infoplist_path}======&quot;

// PlistBuddy其实是一个OSX系统上读取plist文件的工具，它的位置在/usr/libexec/PlistBuddy，输出就用-c &quot;print CFBundleShortVersionString&quot; 后面接我们要读的plist的位置${project_infoplist_path}。
#取版本号
bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; ${project_infoplist_path})
echo &quot;======版本号：${bundleShortVersion}======&quot;

#配置文件路径
buildConfig=${project_path}/${project_name}/Classes/Constant/Constant.h

#URL配置文件路径
urlTypePlist_Path=&quot;${project_path}/${project_name}/Classes/APPConfig/    SNUrlDomainManagerUrlType.plist&quot;
</code></pre><h6 id="定义配置函数"><a href="#定义配置函数" class="headerlink" title="定义配置函数"></a>定义配置函数</h6><pre><code>#定义配置函数
###########################################定义函数###########################################

function config()
{
#修改环境配置
#pre
// grep -n表示显示行号 -i表示不区分大小写，tail -1是查看最后1行内容，写几就是查看几行，cut  -d 后面接了一个符号“：”，代表以：作为分段，-f  1是取分段后的第一个。
preConfigLine=$(grep -n &quot;kPreTest&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $preConfigLine ]; then
// $1代表我们输入的第一个参数，-e是检查文件是否存在，sed -i &apos;&apos;是进行替换的操作，s/^.*$/#define kPreTest        1/的意思是，将刚才搜到的行号preConfigLine，这一行全都替换为#define kPreTest        1。
if [[ $1 = &quot;-pre&quot; ]]; then
sed -i &apos;&apos; -e &quot;${preConfigLine}s/^.*$/#define kPreTest        1/&quot; ${buildConfig}
else
sed -i &apos;&apos; -e &quot;${preConfigLine}s/^.*$/\/\/#define kPreTest        1/&quot; ${buildConfig}
fi
else
echo -e &quot;\033[31m 未找到配置： kPreTest \033[0m&quot;
fi

#sit
sitConfigLine=$(grep -n &quot;kSitTest&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $sitConfigLine ]; then
if [[ $1 = &quot;-sit&quot; ]]; then
sed -i &apos;&apos; -e &quot;${sitConfigLine}s/^.*$/#define kSitTest        1/&quot; ${buildConfig}
else
sed -i &apos;&apos; -e &quot;${sitConfigLine}s/^.*$/\/\/#define kSitTest        1/&quot; ${buildConfig}
fi
else
echo -e &quot;\033[31m 未找到配置： kSitTest \033[0m&quot;
fi

#release
releaseConfigLine=$(grep -n &quot;kReleaseH&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $releaseConfigLine ]; then
if [[ $1 = &quot;-prd&quot; ]]; then
sed -i &apos;&apos; -e &quot;${releaseConfigLine}s/^.*$/#define kReleaseH        1/&quot; ${buildConfig}
else
sed -i &apos;&apos; -e &quot;${releaseConfigLine}s/^.*$/\/\/#define kReleaseH        1/&quot; ${buildConfig}
fi
else
echo -e &quot;\033[31m 未找到配置： kReleaseH \033[0m&quot;
fi
</code></pre><h6 id="检查信息搜集服务器"><a href="#检查信息搜集服务器" class="headerlink" title="检查信息搜集服务器"></a>检查信息搜集服务器</h6><pre><code>#2.3 检查信息搜集服务器
#snclick pre
tPreConfigLine=$(grep -n &quot;kPreInfoTest&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $tPreConfigLine ]; then
sed -i &apos;&apos; -e &quot;${tPreConfigLine}s/^.*$/\/\/#define kPreInfoTest        1/&quot; ${buildConfig}
else
echo -e &quot;\033[31m 未找到配置： kPreInfoTest \033[0m&quot;
fi

#snclick sit
tSitConfigLine=$(grep -n &quot;kSitInfoTest&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $tSitConfigLine ]; then
// 判断是否发布状态，是的话，注释kSitInfoTest
if [[ $2 = &quot;-publish&quot; ]]; then
sed -i &apos;&apos; -e &quot;${tSitConfigLine}s/^.*$/\/\/#define kSitInfoTest        1/&quot; ${buildConfig}
else
sed -i &apos;&apos; -e &quot;${tSitConfigLine}s/^.*$/#define kSitInfoTest        1/&quot; ${buildConfig}
fi
else
echo -e &quot;\033[31m 未找到配置： kSitInfoTest \033[0m&quot;
fi

#snclick release
tReleaseConfigLine=$(grep -n &quot;kReleaseInfoH&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $tReleaseConfigLine ]; then
if [[ $2 = &quot;-publish&quot; ]]; then
sed -i &apos;&apos; -e &quot;${tReleaseConfigLine}s/^.*$/#define kReleaseInfoH        1/&quot; ${buildConfig}
else
sed -i &apos;&apos; -e &quot;${tReleaseConfigLine}s/^.*$/\/\/#define kReleaseInfoH        1/&quot; ${buildConfig}
fi
else
echo -e &quot;\033[31m 未找到配置： kReleaseInfoH \033[0m&quot;
fi
</code></pre><h6 id="检查打印开关"><a href="#检查打印开关" class="headerlink" title="检查打印开关"></a>检查打印开关</h6><pre><code>// “\”这里后面要接特殊符号，if [ $logLine ]是检查变量是否存在的格式。
#2.4 检查打印开关
logLine=$(grep -n &quot;define\ DEBUGLOG&quot; &quot;${buildConfig}&quot; | tail -1 | cut  -d  &quot;:&quot;  -f  1)
if [ $logLine ]; then
sed -i &apos;&apos; -e &quot;${logLine}s/^.*$/\/\/#define DEBUGLOG 1/&quot; ${buildConfig}
else
echo -e &quot;\033[31m 未找到配置： DEBUGLOG \033[0m&quot;
fi

#如果是发布，再检查下bundleIdentifier 和 国际化名称
if [[ $2 = &quot;-publish&quot; ]]; then
#修改bundleIdentifier
bundleIdNew=&quot;${bundle_id}${versionShort}prd&quot;
/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier ${bundle_id}&quot; ${project_infoplist_path}
</code></pre><h6 id="国际化名称"><a href="#国际化名称" class="headerlink" title="国际化名称"></a>国际化名称</h6><pre><code>// s/pattern/xxxx/ 是sed命令，用来做字符串替换，pattern是要被替换的字符串的正则表达式，
#国际化名称
#infoString=${project_path}/${project_name}/zh-Hans.lproj/InfoPlist.strings
#sed -i &apos;&apos; -e &quot;4s/^.*$/CFBundleDisplayName = \&quot;${app_name}\&quot;;/&quot; ${infoString}

#发布时要打开https证书信任验证
validatesSecureFile=${project_path}/${project_name}/Common/Http/HttpMsgCtrl.mm
validatesSecureLine=$(grep -n &quot;request.validatesSecureCertificate&quot; &quot;${validatesSecureFile}&quot; | tail -1 | cut -d &quot;:&quot; -f 1)
if [ $validatesSecureLine ]; then
sed -i &apos;&apos; -e &quot;${validatesSecureLine}s/NO/YES/g&quot; ${validatesSecureFile}
else
echo -e &quot;\033[31m 未找到：validatesSecureCertificate \033[0m&quot;
fi
fi
}
</code></pre><p>检验参数<br>$0 ： ./test.sh,即命令本身，相当于C/C++中的argv[0] </p>
<p>$1 ： -f,第一个参数 </p>
<p>$2 ： config.conf </p>
<p>$3, $4 … ：类推 </p>
<p>$#  参数的个数，不包括命令本身，上例中$#为4. </p>
<p>$@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v –prefix=/home </p>
<p>$* ：和$@相同 </p>
<pre><code>##检验参数
#检查是否含-u参数，包含即上传
needUpload=false
#检查打什么包 -pre -sit -prd 如果三者都没有，默认都打
prd_should=false
pre_should=false
sit_should=false

#只修改配置
just_config=false
#忽略证书检查
ignore_check_codesign=true

if [[ $1 = &quot;config&quot; ]]; then
config $2 $3
exit
fi
// $#代表参数个数，-gt代表大于的判断，-eq等于，-ne不等于，le小于，$arg代表参数，$@是所有参数，下面命令的意思是遍历所有参数，判断并赋值变量。
if [[ $# -gt 0 ]]; then
for arg in &quot;$@&quot;
do
if [[ $arg = &quot;-u&quot; ]]; then
needUpload=true
elif [[ $arg = &quot;-pre&quot; ]]; then
pre_should=true
elif [[ $arg = &quot;-prd&quot; ]]; then
prd_should=true
elif [[ $arg = &quot;-sit&quot; ]]; then
sit_should=true
elif [[ $arg = &quot;-all&quot; ]]; then
pre_should=true
prd_should=true
sit_should=true
elif [[ $arg = &quot;-ignore-codesign&quot; ]]; then
ignore_check_codesign=true
fi
done
fi

#如果没有设置，默认都为yes
if ! $prd_should &amp;&amp; ! $pre_should &amp;&amp; ! $sit_should; then
pre_should=true
prd_should=true
sit_should=true
fi
</code></pre><h6 id="检查xcodebuild版本"><a href="#检查xcodebuild版本" class="headerlink" title="检查xcodebuild版本"></a>检查xcodebuild版本</h6><pre><code>#echo &quot;======检查是否支持iphoneos7.0======&quot;
#isSupport7=$(xcodebuild -showsdks | grep &quot;iphoneos7&quot;)
#isSupport8=$(xcodebuild -showsdks | grep &quot;iphoneos8.0&quot;)
#if [ &quot;${isSupport7}&quot; == &quot;&quot; ] -a [ &quot;${isSupport8}&quot; == &quot;&quot; ]; then
#    echo -e &quot;\033[31m 请升级你的命令行版本，使其支持ios7.0以上 \033[0m&quot;
#    exit
#fi
</code></pre><h6 id="编译配置打印到文件中"><a href="#编译配置打印到文件中" class="headerlink" title="编译配置打印到文件中"></a>编译配置打印到文件中</h6><pre><code>// result_path是上面自己创建的带时间的文件夹，在这个文件夹下生成一个txt文件，用于将当前工程 build setting 的配置参数的结果保存。 

setting_out=${result_path}/build_setting.txt
${xcode_build}  -showBuildSettings &gt; ${setting_out}
</code></pre><h6 id="编译路径"><a href="#编译路径" class="headerlink" title="编译路径"></a>编译路径</h6><pre><code>// -o 只输出文件中匹配到的部分,^一行开头 .*任意长字符 $一行结束 ^.*$ 表示整行。CONFIGURATION_BUILD_DIR里面会保存着xcode编译的路径。
#编译路径
build_dir=$(grep &quot;CONFIGURATION_BUILD_DIR&quot; &quot;${setting_out}&quot; | cut  -d  &quot;=&quot;  -f  2 | grep -o &quot;[^ ]\+\( \+[^ ]\+\)*&quot;)
echo &quot;编译路径：${build_dir}&quot;
</code></pre><h6 id="打包完的程序目录"><a href="#打包完的程序目录" class="headerlink" title="打包完的程序目录"></a>打包完的程序目录</h6><pre><code>#打包完的程序目录
appDir=${build_dir}/${target_name}.app;
#dSYM的路径
dsymDir=${build_dir}/${target_name}.app.dSYM;
if ! $ignore_check_codesign; then 
</code></pre><h6 id="检查工程中证书的选择"><a href="#检查工程中证书的选择" class="headerlink" title="检查工程中证书的选择"></a>检查工程中证书的选择</h6><pre><code>#检查工程中证书的选择
echo &quot;======检查是否选择了正确的发布证书======&quot;

codeSign=$(grep &quot;CODE_SIGN_IDENTITY&quot; &quot;${setting_out}&quot; | cut  -d  &quot;=&quot;  -f  2 | grep -o &quot;[^ ]\+\( \+[^ ]\+\)*&quot;)
rightDistributionSign=&quot;iPhone Distribution: Suning Appliance Co., Ltd.&quot;
if [ &quot;${codeSign}&quot; != &quot;${rightDistributionSign}&quot; ]; then
echo -e &quot;\033[31m 错误的证书:${codeSign}，请进入xcode选择证书为:${rightDistributionSign} \033[0m&quot;
exit
fi
</code></pre><h6 id="检查授权文件"><a href="#检查授权文件" class="headerlink" title="检查授权文件"></a>检查授权文件</h6><pre><code>#检查授权文件
echo &quot;======检查是否选择了正确的签名文件======&quot;
provisionProfile=$(grep &quot;PROVISIONING_PROFILE[^_]&quot; &quot;${setting_out}&quot; | cut  -d  &quot;=&quot;  -f  2 | grep -o &quot;[^ ]\+\( \+[^ ]\+\)*&quot;)
rightProvision=&quot;c59f649f-edb5-4a18-a4fe-870eb7b52d8d&quot;   
#这个是企业证书的id
if [ &quot;${provisionProfile}&quot; != &quot;${rightProvision}&quot; ]; then
echo -e ${provisionProfile}
echo -e &quot;\033[31m 错误的签名，请进入xcode重新选择授权文件 \033[0m&quot;
exit
fi
fi

versionShort=$(echo ${bundleShortVersion} | sed &quot;s/\.//g&quot;)

#############################################PRD#############################################
</code></pre><p>打生产环境测试包 </p>
<pre><code>if $prd_should; then 
#打生产环境测试包
echo &quot;======打生产环境的测试包======&quot;
echo &quot;======修改配置中======&quot;
</code></pre><p>修改URL配置  </p>
<pre><code>// urlTypePlist_Path是上面得到的URLDomin的地址
#修改URL配置
/usr/libexec/PlistBuddy -c &quot;set URLConfig 0&quot; ${urlTypePlist_Path}
</code></pre><p>修改bundleIdentifier </p>
<pre><code>#修改bundleIdentifier
bundleIdNew=&quot;${bundle_id}${versionShort}prd&quot;
/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier ${bundleIdNew}&quot; ${project_infoplist_path}
</code></pre><p>修改环境配置 </p>
<pre><code>#修改环境配置
config -prd;
</code></pre><p>国际化名称 </p>
<pre><code>#国际化名称
#infoString=${project_path}/${project_name}/zh-Hans.lproj/InfoPlist.strings
#sed -i &apos;&apos; -e &quot;4s/^.*$/CFBundleDisplayName = \&quot;PRD${versionShort}.$(date +%m%d%H)\&quot;;/&quot; ${infoString}
</code></pre><p>编译工程</p>
<pre><code>#编译工程
${xcode_build} -sdk iphoneos build || exit
</code></pre><p>ipa名称 </p>
<pre><code>#ipa名称
ipa_name=&quot;${result_path}/${bundleIdNew}.ipa&quot;
</code></pre><p>先打第一个appStore渠道的包 </p>
<pre><code>#先打第一个appStore渠道的包
xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot;
#xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot; --sign &quot;${enterpriseSign}&quot; --embed &quot;${enterpriseEmbed}&quot;

拷贝过来.app和.app.dSYM放在子目录 
// mkdir -p 是创建两级目录，相当于执行两次mkdir ，cp -R是拷贝文件和它所在的目录
#拷贝过来.app和.app.dSYM放在子目录
mkdir -p &quot;${result_path}/prd&quot;
cp -R &quot;${appDir}&quot; &quot;${result_path}/prd/${target_name}.app&quot;
cp -R &quot;${dsymDir}&quot; &quot;${result_path}/prd/${target_name}.app.dSYM&quot; 
</code></pre><p>上传测试包prd </p>
<pre><code>#上传测试包prd
// curl -F是上传文件的命令
if $needUpload; then
curl -F &quot;app=${appId}&quot; -F &quot;version=${versionId}&quot; -F &quot;bundleIdentifier=${bundleIdNew}&quot; -F &quot;desc=${bundleIdNew}&quot; -F &quot;file=@${ipa_name}&quot; ${uploadUrl}
fi
fi

#############################################PRE#############################################

if $pre_should; then
#打PRE环境测试包
echo &quot;======打PRE环境的测试包======&quot;
echo &quot;======修改配置中======&quot;

#修改URL配置
/usr/libexec/PlistBuddy -c &quot;set URLConfig 1&quot; ${urlTypePlist_Path}

#修改bundleIdentifier
bundleIdNew=&quot;${bundle_id}${versionShort}pre&quot;
/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier ${bundleIdNew}&quot; ${project_infoplist_path}

#修改环境配置
config -pre

#国际化名称
#infoString=${project_path}/${project_name}/zh-Hans.lproj/InfoPlist.strings
#sed -i &apos;&apos; -e &quot;4s/^.*$/CFBundleDisplayName = \&quot;PRE${versionShort}.$(date +%m%d%H)\&quot;;/&quot; ${infoString}

#编译工程
${xcode_build} -sdk iphoneos build || exit

#ipa名称
ipa_name=&quot;${result_path}/${bundleIdNew}.ipa&quot;
#先打第一个appStore渠道的包
xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot;
#xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot; --sign &quot;${enterpriseSign}&quot; --embed &quot;${enterpriseEmbed}&quot;
#拷贝过来.app和.app.dSYM放在子目录
mkdir -p &quot;${result_path}/pre&quot;
cp -R &quot;${appDir}&quot; &quot;${result_path}/pre/${target_name}.app&quot;
cp -R &quot;${dsymDir}&quot; &quot;${result_path}/pre/${target_name}.app.dSYM&quot;

#上传测试包pre
if $needUpload; then
curl -F &quot;app=${appId}&quot; -F &quot;version=${versionId}&quot; -F &quot;bundleIdentifier=${bundleIdNew}&quot; -F &quot;desc=${bundleIdNew}&quot; -F &quot;file=@${ipa_name}&quot; ${uploadUrl}
fi
fi

#############################################SIT#############################################

if $sit_should; then
#打PRE环境测试包
echo &quot;======打SIT环境的测试包======&quot;
echo &quot;======修改配置中======&quot;

 #修改URL配置
 /usr/libexec/PlistBuddy -c &quot;set URLConfig 2&quot; ${urlTypePlist_Path}

#修改bundleIdentifier
bundleIdNew=&quot;${bundle_id}${versionShort}sit&quot;
/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier ${bundleIdNew}&quot; ${project_infoplist_path}
#修改环境配置
config -sit
#国际化名称
#infoString=${project_path}/${project_name}/zh-Hans.lproj/InfoPlist.strings
#sed -i &apos;&apos; -e &quot;4s/^.*$/CFBundleDisplayName = \&quot;SIT${versionShort}.$(date +%m%d%H)\&quot;;/&quot; ${infoString}

#编译工程
${xcode_build} -sdk iphoneos build || exit

#ipa名称
ipa_name=&quot;${result_path}/${bundleIdNew}.ipa&quot;
#先打第一个appStore渠道的包
xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot;
#xcrun -sdk iphoneos PackageApplication -v &quot;${appDir}&quot; -o &quot;${ipa_name}&quot; --sign &quot;${enterpriseSign}&quot; --embed &quot;${enterpriseEmbed}&quot;
#拷贝过来.app和.app.dSYM放在子目录
mkdir -p &quot;${result_path}/sit&quot;
cp -R &quot;${appDir}&quot; &quot;${result_path}/sit/${target_name}.app&quot;
cp -R &quot;${dsymDir}&quot; &quot;${result_path}/sit/${target_name}.app.dSYM&quot;

#上传测试包sit
if $needUpload; then
curl -F &quot;app=${appId}&quot; -F &quot;version=${versionId}&quot; -F &quot;bundleIdentifier=${bundleIdNew}&quot; -F &quot;desc=${bundleIdNew}&quot; -F &quot;file=@${ipa_name}&quot; ${uploadUrl}
fi
fi

#############################################还原配置#############################################

#修改URL配置
/usr/libexec/PlistBuddy -c &quot;set URLConfig 0&quot; ${urlTypePlist_Path}

/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier ${bundle_id}&quot; ${project_infoplist_path}
sed -i &apos;&apos; -e &quot;4s/^.*$/CFBundleDisplayName = \&quot;${app_name}\&quot;;/&quot; ${infoString}
</code></pre>
	
	</div>
  <a type="button" href="/2016/10/30/shell打包脚本解读/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/10/30/翻翻小视频录制原理/">翻翻小视频录制原理</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-10-30  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h4 id="微信小视频录制"><a href="#微信小视频录制" class="headerlink" title="微信小视频录制"></a>微信小视频录制</h4><h5 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h5><p>1，固定4：3的拍摄比例 </p>
<p>2，录制使用和时长的提示动画 </p>
<p>3，双击放大拍摄内容 </p>
<p>4，固定15秒的倒计时动画 </p>
<p>6，按住不放的按钮录制 </p>
<p>7，录制完成后自动上传 </p>
<h5 id="AVFoundation的简介"><a href="#AVFoundation的简介" class="headerlink" title="AVFoundation的简介"></a>AVFoundation的简介</h5><p><strong>AVFoundation</strong>中提供了很多现成的播放器和录音机，但事实上它还有更加底层的内容可以供开发者使用，因为AVFoundation中有很多和底层输入、输出设备打交道的类，依靠这些类，开发人员就不必只使用封装好的AVAudioPlayer、AVAudioRecorder、AVPlayer等，而是操作输入设备（摄像头和麦克风等）。  </p>
<p><strong>AVCaptureDevice：</strong>输入设备，包括摄像头麦克风等。 </p>
<p><strong>AVCaptureOutput：</strong>输出数据管理对象，用于接收各类输出数据，通常使用AVCaptureVideoDataOutput、AVCaptureAudioDataOutput等，该对象呗添加到AVCaptureSession中管理， </p>
<p><strong>AVCaptureVideoPreviewLayer：</strong>相机拍摄预览图层，是CALayer的子类，该对象可以实时查看效果，创建时必须制定<br>对应的AVCaptureSession。 </p>
<p><strong>AVCaptureSession：</strong>媒体捕捉会话，负责把捕捉的音视频数据输出到设备中，一个AVCaptureSession可以有多个输入输出。</p>
<p><strong>AVAsset：</strong>多媒体一般是以文件或者流的形式存在，直接操作多媒体文件不方便，AVFoundation提供了一个多媒体载体类AVAsset。</p>
<p> <strong>mvhd（movie header）</strong>是视频的描述部分，包含了视频的基本信息，比如时长，创建时间等，preferredRate、preferredVolume，默认速度和音量，creationDate创建时间，对应到AVAsset中。<br><strong>CMTime：</strong>这个结构体中有value、timesacle、duration，duration是由视频中的duration和timescale共同组成。<br><strong>AVAssetTrack：</strong> 一般视频至少有两个轨道，一个视频的一个音频的，AVFoundation中的AVAssetTrack专门用来承载多媒体中的track。它的tkhd中包含了duration,rate,volume,created，还有一个track的唯一标识，track id。<br>获取帧率和比特率的方法：  </p>
<pre><code>AVAssetTrack *videoTrack = nil;
AVURLAsset *asset = [AVAsset assetWithURL:[NSURL fileURLWithPath:originalVideo]];
NSArray *videoTracks = [asset tracksWithMediaType:AVMediaTypeVideo];

CMFormatDescriptionRef formatDescription = NULL;
NSArray *formatDescriptions = [videoTrack formatDescriptions];
if ([formatDescriptions count] &gt; 0)
formatDescription = (CMFormatDescriptionRef)[formatDescriptions objectAtIndex:0];

if ([videoTracks count] &gt; 0)
videoTrack = [videoTracks objectAtIndex:0];

CGSize trackDimensions = {
.width = 0.0,
.height = 0.0,
};
trackDimensions = [videoTrack naturalSize];
// 获取分辨率
int width = trackDimensions.width;
int height = trackDimensions.height;
NSLog(@&quot;Resolution = %d X %d&quot;,width ,height); 
float frameRate = [videoTrack nominalFrameRate];//获取帧率
float bps = [videoTrack estimatedDataRate];//获取比特率
NSLog(@&quot;Frame rate == %f&quot;,frameRate);
NSLog(@&quot;bps rate == %f&quot;,bps);
</code></pre><h5 id="AVFoundation使用流程"><a href="#AVFoundation使用流程" class="headerlink" title="AVFoundation使用流程"></a>AVFoundation使用流程</h5><p>1，创建AVCaptureSession对象，以备其它类的使用。 </p>
<p>2，使用AVCaptureDevice的静态方法获得需要的使用设备，我们要做的录像功能需要获得摄像头设备。  </p>
<p>3，利用输入设备AVCaptureDevice初始化AVCaptureDeviceInput对象。  </p>
<p>4，初始化输入输出数据的管理对象（例如AVCaptureMovieFileOutput），并将其添加到媒体会话管理对象AVCaptureSession中。  </p>
<p>5，创建预览图层AVCaptureVideoPreviewLayer并指定Session，添加到可显示的容器中。调用AVCaptureSession的startRuning方法开始捕获。</p>
<p>6，将捕获的音视频输出到文件。 </p>
<h5 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h5><p>1，我们需要一个负责录制的类，SHMovieRecorder，它提供一个初始化方法，可设定最长录制时间。提供一个变量，设置宽、高，授权检测的block，初始化预设的prepareCaptureWithBlock:。<br>2，初始化工作，初始化一个AVCaptureSession对象。权限检查，使用枚举CaptureAVSetupResult记录权限状态。在自己创建的dispatch_queue_t sessionQueue线程中，创建AVCaptureDevice的对象，再创建AVCaptureDeviceInput对象。  </p>
<pre><code>- (void)setup{
创建AVCaptureSession对象
self.session = [[AVCaptureSession alloc] init]; 
//权限检查
switch ([AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]) {
        case AVAuthorizationStatusNotDetermined: {

            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
                if (granted) {
                    self.result = CaptureAVSetupResultSuccess;
                }
            }];
            break;
        }
        case AVAuthorizationStatusAuthorized: {

            break;
        }
        default:{
            self.result = CaptureAVSetupResultCameraNotAuthorized;
        }
    }

    if ( self.result != CaptureAVSetupResultSuccess) {

        if (self.authorizationResultBlock) {
            self.authorizationResultBlock(NO);
        }
        return;
    }

    // 初始化AVCaptureDevice及AVCaptureDevice对象

    dispatch_async(self.sessionQueue, ^{


        AVCaptureDevice *captureDevice = [[self class] deviceWithMediaType:AVMediaTypeVideo preferringPosition:AVCaptureDevicePositionBack];

        _captureDevice = captureDevice;

        NSError *error = nil;
        _videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:captureDevice error:&amp;error];

        if (!_videoDeviceInput) {
            NSLog(@&quot;未找到设备&quot;);
        }

        //配置会话
        [self.session beginConfiguration];
        // NSProcessInfo用于获取当前正在执行的进程信息，包括设备的名称，操作系统版本，进程标识符，进程环境，参数等信息,这里是为了区分是否是4的单核机型。
        // if ( [NSProcessInfo processInfo].processorCount == 1 )
        // 录制帧数设置
         if ([self.session canSetSessionPreset:AVCaptureSessionPreset640x480]) {
                [self.session setSessionPreset:AVCaptureSessionPreset640x480];
            }
            // 视频的帧率小于24时，会觉得跳帧
            frameRate = 30;

         // 每帧的时间,每秒30帧，每到这个时间让captureDevice获取一次画面
        CMTime frameDuration = CMTimeMake( 1, frameRate );

        // 改变相机的参数，这里，相机设备在改变某些参数前必须先锁定，知道改变结束才能解锁。
        if ( [_captureDevice lockForConfiguration:&amp;error] ) {
            _captureDevice.activeVideoMaxFrameDuration = frameDuration;
            _captureDevice.activeVideoMinFrameDuration = frameDuration;
            [_captureDevice unlockForConfiguration];
        }
        else {
            NSLog( @&quot;videoDevice lockForConfiguration returned error %@&quot;, error );
        }

        // 分别设置video和audio的input的output
        AVCaptureAudioDataOutput *audioOut = [[AVCaptureAudioDataOutput alloc] init];

        if ( [self.session canAddOutput:audioOut] ) {
            [self.session addOutput:audioOut];
        }
        _audioConnection = [audioOut connectionWithMediaType:AVMediaTypeAudio];
        [self.session commitConfiguration];

        // 设置通知
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sessionWasInterrupted:) name:AVCaptureSessionWasInterruptedNotification object:self.session]; 
</code></pre><p>3，预览摄像机，我们可以先用PreviewLayer来显示一下camera buffer中的内容，这也将是相机的“取景器”，这里我们使用AVCaptureVideoPreviewLayer，可以用来快速呈现摄像头收集到的原始数据。我们可以设置它的背景色，videoGravity，还可以将它从父layer中取出来，放到我们自己创建的视图preview上。 当点击拍摄按钮时，我们打开摄像功能。 </p>
<pre><code>// 初始化相机
[_recorder prepareCaptureWithBlock:^{

    // 预览图层
    AVCaptureVideoPreviewLayer * preview = [_recorder getPreviewLayer];
    preview.backgroundColor = [UIColor blackColor].CGColor;
    preview.videoGravity = AVLayerVideoGravityResizeAspectFill;
    [preview removeFromSuperlayer];
    preview.frame = CGRectInset(self.preview.bounds, 0, CGRectGetHeight(self.preview.bounds)-(kScreenWidth/4*3)/2);
    preview.frame = CGRectMake(0,0, kScreenWidth, kScreenWidth*4/3);
    [self.preview.layer addSublayer:preview];

}];
</code></pre><p>点击录像后  </p>
<pre><code>if (![_session isRunning]) {
[_session startRunning];
}
NSLog(@&quot;开始录像&quot;);
</code></pre><p>4，获取拍摄内容，监听AVCaptureVideoDataOutputSampleBufferDelegate</p>
<p>5，监听摄像状态，我们用一个ENUM表示，当我们检测到的状态是SHStateBegin，我们要在它的block中处理初始化摄像机，和初始化时间条的动画。而检测到WKStateCancle时，我们停止录制和动画。<br>6，录制完成，我们需要定义一个录制完成的blcok，由我们的SHMovieRecorder提供，定义代表拍摄完成状态的ENUM，在BLOCK中返回拍摄完成状态和录制的视频内容，拿到内容进行播放等处理。<br>7,视频文件写入，创建一个专门用于文件写入的类：WKMovieWriter，需要一个_recordingURL变量和_cropSize剪裁大小变量。需要配置的有，初始化文件存放地址path，名称根本videoWriter.outputURL获得，初始化self.videoWriter，添加图像输入，初始化刻录，初始化方法添加url和文件格式，这里使用AVFileTypeMPEG4。 最后设置视频的大小，AVVideoHeightKey和AVVideoWidthKey，AVVideoScalingModeKey（填充方式）。    </p>
<pre><code>//初始化
NSString *betaCompressionDirectory = [[_recordingURL absoluteString] stringByReplacingOccurrencesOfString:@&quot;file://&quot; withString:@&quot;&quot;];

NSError *error = nil;

unlink([betaCompressionDirectory UTF8String]);
//添加图像输入
//--------------------------------------------初始化刻录机--------------------------------------------
self.videoWriter = [[AVAssetWriter alloc] initWithURL:[NSURL fileURLWithPath:betaCompressionDirectory]
                                             fileType:AVFileTypeMPEG4
                                                error:&amp;error];
</code></pre><p> 接下来初始化图像信息输入参数，参数字典videoSettings中需要存放。IOS端的视频压缩用的是AVAssetWriter硬编码。AVVideoCodecKey:AVVideoCodecH264，解码速度回比较快。AVVideoCodecJPEG输出jpg格式的文件，AVVideoCodecAppleProRes4444输出mov的高清视频。用字典初始化AVAssetWriterInput。<br>硬编码：使用非CPU进行编码，如显卡GPU、ASIC芯片等。硬编码性能高，很多产品在GPU硬件平台抑制了优秀的软编码算法，质量等同于软编码。软编码使用CPU编码，显现简单，直接，但容易使CPU负载过重。 </p>
<pre><code>videoSettings = [NSDictionary dictionaryWithObjectsAndKeys:
                 AVVideoCodecH264, AVVideoCodecKey,
                 [NSNumber numberWithInt:_cropSize.width], AVVideoWidthKey,
                 [NSNumber numberWithInt:_cropSize.height], AVVideoHeightKey,
                 AVVideoScalingModeResizeAspectFill,AVVideoScalingModeKey,
                 nil];
</code></pre><p>接下来设置缓冲区参数设置  </p>
<pre><code>//--------------------------------------------缓冲区参数设置--------------------------------------------
NSDictionary *sourcePixelBufferAttributesDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
                                                                                                                 [NSNumber numberWithInt:kCVPixelFormatType_32ARGB], kCVPixelBufferPixelFormatTypeKey, nil];

self.adaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:self.videoInput

                                                                                sourcePixelBufferAttributes:sourcePixelBufferAttributesDictionary];
</code></pre><p>音频的输入设置====== </p>
<p>设置AVFormatIDKey录音格式为aac格式，AAC代表Advanced Audio Coding(高级音频编码)，是一种由MPEG-4标准定义的有损音频压缩格式。<br>设置音频的通道数AVNumberOfChannelsKey，1为单声道，2为立体声。<br>AVSampleRateKey采样频率为64000，它影响音频的质量。<br>设置AVEncoderBitRateKey比特率，音频的编码比特率，也就是取样率，单位为kbps即千位每秒，每秒取样率越高，越清晰，文件也越大。 一般为128000bps。</p>
<p>比特率值与现实音频对照 </p>
<p>16Kbps=电话音质 </p>
<p>24Kbps=增加电话音质、短波广播、长波广播、欧洲制式中波广播</p>
<p>40Kbps=美国制式中波广播 </p>
<p>56Kbps=话音</p>
<p>64Kbps=增加话音（手机铃声最佳比特率设定值、手机单声道MP3播放器最佳设定值） </p>
<p>112Kbps=FM调频立体声广播 </p>
<p>128Kbps=磁带（手机立体声MP3播放器最佳设定值、低档MP3播放器最佳设定值） </p>
<p>160Kbps=HIFI高保真（中高档MP3播放器最佳设定值） </p>
<p>192Kbps=CD（高档MP3播放器最佳设定值） </p>
<p>256Kbps=Studio音乐工作室（音乐发烧友适用） </p>
<pre><code>//音频配置 
NSDictionary* audioOutputSettings = nil;
audioOutputSettings = [ NSDictionary dictionaryWithObjectsAndKeys:

                       [ NSNumber numberWithInt: kAudioFormatMPEG4AAC ], AVFormatIDKey,

                       [ NSNumber numberWithInt:64000], AVEncoderBitRateKey,

                       [ NSNumber numberWithFloat: 44100.0 ], AVSampleRateKey,

                       [ NSNumber numberWithInt: 1 ], AVNumberOfChannelsKey,

                       [ NSData dataWithBytes: &amp;acl length: sizeof( acl ) ], AVChannelLayoutKey,

                       nil ];

self.audioInput = [AVAssetWriterInput  assetWriterInputWithMediaType: AVMediaTypeAudio
                                                      outputSettings: audioOutputSettings];
self.audioInput.expectsMediaDataInRealTime = YES;


//图像和语音输入添加到刻录机
[self.videoWriter addInput:self.audioInput];

[self.videoWriter addInput:self.videoInput];
</code></pre><p>6，文件写入</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>
	
	</div>
  <a type="button" href="/2016/10/30/翻翻小视频录制原理/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/10/16/使用FMDB及CoreData实现多表查询/">使用FMDB及CoreData实现多表查询</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-10-16  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="使用FMDB及CoreData实现多表查询"><a href="#使用FMDB及CoreData实现多表查询" class="headerlink" title="使用FMDB及CoreData实现多表查询"></a>使用FMDB及CoreData实现多表查询</h1><h2 id="一、CoreData"><a href="#一、CoreData" class="headerlink" title="一、CoreData"></a>一、CoreData</h2><p>二零一四年做过一个电子书城的项目，由于数据模型不是特别复杂，最终选择使用CoreData来做本地电子书的数据管理。实现的思路是：在程序中定义了一个数据库相关的manager类，它提供一个单例，用来共享数据操作上下文NSManagedObjectContext，还有一个负责数据库增删查改操作的DateBaseTool类，并提供接口和单例，在程序的其它部分调用接口操作。 下面试相关代码：</p>
<h5 id="加载数据库"><a href="#加载数据库" class="headerlink" title="加载数据库"></a>加载数据库</h5><pre><code>// 加载数据库
- (void)initDateBaseWithEntity:(NSString *)entity key:(NSString *)key
{
 EMPLog(@&quot;加载数据库&quot;);
// 创建context
NSManagedObjectContext *context = [[EMPDataManager sharedDataManager] sharedContext];

// 查询请求
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:entity];

// 按照用户姓名升序排序
NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:key ascending:YES];

request.sortDescriptors = @[sort];

_fetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:request managedObjectContext:context sectionNameKeyPath:nil cacheName:nil];

// 设置代理
// _fetchedResultsController.delegate = self;

NSError *error = nil;

if ([_fetchedResultsController performFetch:&amp;error]) {

    EMPLog(@&quot;查询成功&quot;);

} else {

    EMPLog(@&quot;查询失败 %@&quot;, error.localizedDescription);
}
}
</code></pre><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><pre><code> -(Book *)queryEntityByUrl:(NSString *)url
{
NSManagedObjectContext *context = [[EMPDataManager sharedDataManager] sharedContext];

NSFetchRequest *reqeust=[[NSFetchRequest alloc]init];
reqeust.entity=[NSEntityDescription entityForName:@&quot;Book&quot; inManagedObjectContext:context];

NSPredicate *predicate=[NSPredicate predicateWithFormat:@&quot;filePath = %@&quot;,url];
reqeust.predicate=predicate;

NSError *error=nil;
NSArray *retlist=[context executeFetchRequest:reqeust error:&amp;error];
if(error)
{
    NSLog(@&quot;deleteDownloadTask error:%@&quot;,error);
}
return [retlist firstObject];
}
</code></pre><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><pre><code>-(void)addBookWith:(NSString *)bookName path:(NSString *)path image:(NSString *)image success:(EMPAddSuccess)success
{
NSManagedObjectContext *context = [[EMPDataManager sharedDataManager] sharedContext];

Book * oneBook;
if (oneBook == nil) {
    oneBook = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Book&quot; inManagedObjectContext:context];
}

oneBook.sampleName = bookName;
oneBook.sImagePath = image;
oneBook.filePath = path;
oneBook.dowState = kDOWLOADING;
oneBook.dowProgress = 0;

// 上下文保存
if ([context save:nil]) {
    success();
//  NSLog(@&quot;保存成功&quot;);
} else {
    NSLog(@&quot;保存失败!&quot;);
}
}
</code></pre><h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><pre><code>// 先查询
Book * CBook = [self queryEntityByUrl:url];
// 修改数据
CBook.dowState = kDOWLOADING;
// 让上下文保存
[context updatedObjects];
</code></pre><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><pre><code>// 让上下文删除
NSManagedObject * book = [_fetchedResultsController objectAtIndexPath:indexPath];
[context deleteObject:book];
</code></pre><h2 id="二、FMDB的使用"><a href="#二、FMDB的使用" class="headerlink" title="二、FMDB的使用"></a>二、FMDB的使用</h2><h3 id="创建数据库的步骤"><a href="#创建数据库的步骤" class="headerlink" title="创建数据库的步骤"></a>创建数据库的步骤</h3><h5 id="1，-创建数据库"><a href="#1，-创建数据库" class="headerlink" title="1， 创建数据库"></a>1， 创建数据库</h5><pre><code>NSString *filePath=[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;fmdb.sqlite&quot;];
//创建数据库
self.db=[FMDatabase databaseWithPath:filePath];
//打开数据库
if ([self.db open]) {
    NSLog(@&quot;打开数据库成功&quot;);
    //创建表格，除了select外，所有的操作都是更新
    BOOL createTableResult=[self.db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT,name text,age integer)&quot;];
    if (createTableResult) {
        NSLog(@&quot;创建表成功&quot;);
    }else{
        NSLog(@&quot;创建表失败&quot;);
    }
}else{
    NSLog(@&quot;打开数据库失败&quot;);
}
}
// 操作数据库
[self.db executeUpdate:@&quot;INSERT INTO t_student(name,age) VALUES(?,?)&quot;,s_name,s_age];
</code></pre><p>使用FMDatabaseQueue保证线程安全，推荐使用，FMDatabaseQueue是一个串行队列，在多个线程来执行查询和更新时会使用这个类，避免同时访问同一个数据。</p>
<pre><code> NSString *path = [[self _databasePath] stringByAppendingPathComponent:SNYXDabaseName];

 // 创建数据库，并加入到FMDatabaseQueue队列中，且默认打开数据库。
 self.databaseQueue = [FMDatabaseQueue databaseQueueWithPath:
                          path];
 [self.databaseQueue inDatabase:^(FMDatabase *db) {
    //创建表
    BOOL createTableResult=[db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT,name text,age integer)&quot;];
    if (createTableResult) {
        NSLog(@&quot;创建表成功&quot;);
    }else{
        NSLog(@&quot;创建表失败&quot;);
    }
}];
}
</code></pre><h4 id="2，比较版本号"><a href="#2，比较版本号" class="headerlink" title="2，比较版本号"></a>2，比较版本号</h4><p>在userDefault里面保存一份数据库的版本号，在每次打开数据库的时候先判断当前版本号与偏好设置中的是否相同，如果不同则执行更新表操作。</p>
<h4 id="3，操作数据库"><a href="#3，操作数据库" class="headerlink" title="3，操作数据库"></a>3，操作数据库</h4><pre><code>[self.queue inDatabase:^(FMDatabase *db) {
    NSString *sql = [NSString stringWithFormat:
                     @&quot;create table if not exists %@ (id integer primary key autoincrement);&quot;,weak_self.tableName];
    if ([db executeUpdate:sql]) {
</code></pre><h4 id="4，封装一个数据库操作的专用队列"><a href="#4，封装一个数据库操作的专用队列" class="headerlink" title="4，封装一个数据库操作的专用队列"></a>4，封装一个数据库操作的专用队列</h4><pre><code>static inline void dispatch_async_on_database_queue(dispatch_block_t block) {
if (block) dispatch_async(snyxdatabase_opration_queue(), block);
}

// 获取数据库的队列
static inline dispatch_queue_t snyxdatabase_opration_queue(void){
static dispatch_queue_t queue = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    queue = dispatch_queue_create(&quot;snyxdatabase_opration_queue&quot;, DISPATCH_QUEUE_SERIAL);
});
return queue;
}
</code></pre><h4 id="5，更新操作"><a href="#5，更新操作" class="headerlink" title="5，更新操作"></a>5，更新操作</h4><pre><code>   // 表明定义为结构体，typedef  NS_ENUM(NSInteger,SNYXDatabaseTable){}
   根据参数查询表名和条件语句。他们都写在了SNYXDatabase+Helper.h中，这个类专门负责根据表明返回需要的名称和语句。 
- (void)updateWithTable:(SNYXDatabaseTable)table
        theInfoDict:(NSDictionary *)dict
    complete:(DatabaseResult)complete{

    }
    @weakify(self);
   [self.databaseQueue inDatabase:^(FMDatabase *db) {

    // 我们在更新表之前，先要确定更新的行，要根据主键或者几列来确定，就是在这里实现的：表明，根据字段查询行，得到查询的数据。
    NSString *tableName = [self getTableName:table];
    NSString *condition = [self getDefaultConditionSqlWithTableName:table];
    NSArray *conditionValues = [self getDefaultQueryValues:table dict:dict];
    // 查询结果
    FMResultSet *res = [weak_self executeQuery:sql values:conditionValues db:db];
    // res.next代表有查询结果
        if (res.next) {//说明该条记录存在，执行更新
            [res close];
            NSMutableArray *values = [NSMutableArray array];
            NSMutableString *attStr = [NSMutableString string];
            // 准备查询语句和赋值
            for (NSString *key in dict.allKeys) {
                [attStr appendFormat:@&quot;%@ = ?,&quot;,key];
                [values addObject:dict[key]];
            }
</code></pre><p>小知识： </p>
<p><strong>static inline void–内联函数：</strong>  内联函数和成员函数的区别在于，内联函数加快了函数的执行速度，它是牺牲空间来节省时间的一种设置，因为调用函数需要浪费时间，写成内联函数可以在调用时，使用函数体内容代替函数调用，类似于宏定义，在我们没有复杂的循环语句且调用次数较多时，可以使用内联函数。<br>数据库操作中，很少会关闭数据库的操作，程序关闭时，数据库自然也会关闭，每次重新打开都会消耗性能。</p>
<p><strong>IOS中的类别Category和扩展Extension</strong><br>Category可以为系统类进行拓展，我们可以不用继承系统类，而直接给系统类添加方法，这样既不用生成子类，又方便项目管理，方便源码共享。Category理论上不能添加变量，但是可以使用@dynamic来弥补。类别的优先级较高，可覆盖原类的方法，不可调用super方法，<br>某些情况下，我们需要声明一个@property，它对外只读，对内是可读写，此时可以用Extension，Extension也叫作匿名分类，不像分类的小括号中必须有分类名称。</p>
<pre><code>// 括号内为我们起的分类名称
@implementation NSObject (Category)
</code></pre><h4 id="6，查询语句整理"><a href="#6，查询语句整理" class="headerlink" title="6，查询语句整理"></a>6，查询语句整理</h4><p>我们可能经常会遇到需要手写查询语句的情况，尤其是涉及到多表查询的情况，更需要我们熟练的掌握各种sql语句，下面是一些常用的整理。 </p>
<h5 id="1-普通的条件查询"><a href="#1-普通的条件查询" class="headerlink" title="1.普通的条件查询"></a>1.普通的条件查询</h5><pre><code>SELECT nickname,email FROM testtable 
</code></pre><h5 id="2-筛选查询"><a href="#2-筛选查询" class="headerlink" title="2.筛选查询"></a>2.筛选查询</h5><pre><code>// DISTINCT可以去掉查询的重复数据
SELECT DISTINCT nickname,email FROM testtable 
</code></pre><h5 id="3-限制查询行数"><a href="#3-限制查询行数" class="headerlink" title="3.限制查询行数"></a>3.限制查询行数</h5><pre><code>// 只返回查询的前两行
SELECT TOP 2 nickname,email FROM testtable
// 返回查询到的前百分之20
SELECT TOP 20 PERCENT nickname,email FROM testtable
// 查询符合条件的行数
select count(*)from testtable where %@ = &apos;%@&apos;
// 查询所有符合的数据，但限制20条，或者是从10到20条的分页数据
select  * from testtable where %@ = &apos;%@&apos; limit 20
select  * from testtable where %@ = &apos;%@&apos; limit 10，20
</code></pre><h5 id="4-查询时给表起别名"><a href="#4-查询时给表起别名" class="headerlink" title="4.查询时给表起别名"></a>4.查询时给表起别名</h5><pre><code>// 查询用户表和城市表中，cityid相同的数据的username和cityid两列数据
SELECT `username`,citytable.cityid
FROM `usertable`,`citytable`
WHERE usertable.cityid=citytable.cityid 
</code></pre><h5 id="5-查询条件WHERE和排序"><a href="#5-查询条件WHERE和排序" class="headerlink" title="5.查询条件WHERE和排序"></a>5.查询条件WHERE和排序</h5><pre><code>// where后面可以接各种的运算符&gt;、&gt;=、=、、!&gt;、!= AND
// 下面的排序方式是，先以age进行排序，再根据userid排序（当age相同的情况下，根据userid再排序）
SELECT * FROM `usertable` ORDER BY `age` DESC,`userid` ASC   
</code></pre><h5 id="6-多表连接查询"><a href="#6-多表连接查询" class="headerlink" title="6.多表连接查询"></a>6.多表连接查询</h5><p>连接是关系数据库模型的主要特点，它区别于其它类型的数据库管理，当检索数据时，通过连接操作，查询出存在多个表中的不同实体的信息。连接分下面三种方式： </p>
<p>1，内连接 INNER JOIN<br>我们可以把普通的单张表查询理解为内连接，例如： </p>
<pre><code>// 查询两张表中studentid相同的且都有数据的列
select s.name,m.mark from student s,mark m where s.id=m.studentid
// 它相当于使用内连接
select s.name,m.mark from student s inner join mark m on s.id=m.studentid 
</code></pre><p>2，外左连接 LEFT JOIN </p>
<pre><code>// 将左边的表全部选出来，即便mark表中有些分数没有，也会被查出来，区别于内连接，就是存在左连接表中没有值得数据
select s.name,m.mark from student s left join mark m on s.id=m.studentid 
</code></pre><p>3，外右连接 RIGHT JOIN<br>    // 将右边表的数据全部取出来，无论左表中有没有数据匹配，而后面的on条件语句，其实是相当于一个行的对应，相同的id对应一行。<br>    select s.name,m.mark from student s right join mark m on s.id=m.studentid<br>4，全连接 FILL JOIN<br>    // 将右边表的数据全部取出来，无论左表中有没有数据匹配，而后面的on条件语句，其实是相当于一个行的对应，相同的id对应一行。 </p>
<pre><code>select s.name,m.mark from student s full join mark m on s.id=m.studentid

// 下面是一个在实际项目中用到的查询语句
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSString * sql = [NSString stringWithFormat:@&quot;select DISTINCT A.*, B.%@, B.%@  From %@ as A Left Join %@ as B On A.%@=B.%@  where A.%@ = &apos;%@&apos; and A.%@ = &apos;%@&apos; and A.id &lt; %ld order by id desc limit %ld;&quot;,yx_customer_service_nickname,yx_customer_service_portrait_url,t_OSMessage,t_OSCustomInfo,yx_customer_service_id,yx_customer_service_id,yx_current_user_id,userId,yx_contact_id,contactId,(long)lastId,(long)pageCount]; 
</code></pre><h5 id="7-插入语句"><a href="#7-插入语句" class="headerlink" title="7.插入语句"></a>7.插入语句</h5><pre><code>// 插入一条数据，四个字段
INSERT INTO Persons VALUES (&apos;Gates&apos;, &apos;Bill&apos;, &apos;Xuanwumen 10&apos;, &apos;Beijing&apos;)
// 插入一条数据，只有两个字段
INSERT INTO Persons (LastName, Address) VALUES (&apos;Wilson&apos;, &apos;Champs-Elysees&apos;)  
</code></pre><h5 id="8-删除语句"><a href="#8-删除语句" class="headerlink" title="8.删除语句"></a>8.删除语句</h5><pre><code>// 如果任何条件语句都没有，相当于删除整个表的内容
DELETE FROM Person WHERE LastName = &apos;Wilson&apos;  
</code></pre><h5 id="9-更新语句"><a href="#9-更新语句" class="headerlink" title="9.更新语句"></a>9.更新语句</h5><pre><code>UPDATE Person SET FirstName = &apos;Fred&apos; WHERE LastName = &apos;Wilson&apos;
UPDATE Person SET Address = &apos;Zhongshan 23&apos;, City = &apos;Nanjing&apos;
WHERE LastName = &apos;Wilson&apos; 
</code></pre>
	
	</div>
  <a type="button" href="/2016/10/16/使用FMDB及CoreData实现多表查询/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/10/15/符号化IOS崩溃日志，解读堆栈信息/">符号化IOS崩溃日志，解读堆栈信息</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-10-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="符号化IOS崩溃日志，解读堆栈信息"><a href="#符号化IOS崩溃日志，解读堆栈信息" class="headerlink" title="符号化IOS崩溃日志，解读堆栈信息"></a>符号化IOS崩溃日志，解读堆栈信息</h2><h5 id="产生崩溃日志的几种情况"><a href="#产生崩溃日志的几种情况" class="headerlink" title="产生崩溃日志的几种情况:"></a>产生崩溃日志的几种情况:</h5><p>1, 响应超时。当程序退到后台，applicationDidEnterBackground等这些与UIApplicationDelegate相对应的方法，如果不在有限的时间去完成，操作系统将终止应用，此时会产生崩溃日志。 </p>
<p>2，双击home键退出时，会生成一个崩溃日志。但是注意，双击home按钮后看到的运行过的应用，那些应用不一定是在运行，也不一定是被挂起，应用在后台保留约十分钟，然后操作系统将其终止，所以双击看到的只是表明那是一系列过去打开过的应用，删除那些图标不会产生任何崩溃日志。 </p>
<p>3，低内存的终止。低内存的警告会执行didReceiveMemoryWarning方法，我们可以在里面释放一些不用的资源，如果一直受到内存警告，程序会因为低内存而终止相应，并生成崩溃日志。对于低内存警告产生的警告会很不一样，一般我们最好用instrument找到问题，并修复。再就是提高代码的质量，在didReceiveMemoryWarning方法中处理下数据，将不用的对象释放。</p>
<pre><code>- (void)didReceiveMemoryWarning {
[super didReceiveMemoryWarning];
// Dispose of any resources that can be recreated.
}
</code></pre><h4 id="获取崩溃日志"><a href="#获取崩溃日志" class="headerlink" title="获取崩溃日志"></a>获取崩溃日志</h4><p>1，当我们的应用上线后，或者我们无法通过在真机上调试定位到崩溃时，可以通过查看存在设备中的崩溃日志，定位到我们的break。</p>
<p>2，崩溃日志的位置<br>一种方式是真机连接xcode，找到windows-device-view device log下面的日志列表。</p>
<p>第二种方法是设备与电脑上的iTunes Store同步后，会将崩溃日志保存在电脑上。根据电脑操作系统的不同，崩溃日志将保存在以下位置:</p>
<p>Mac OS X:~/Library/Logs/CrashReporter/MobileDevice/<br>Windows XP: C:Documents and Settings<username>Application DataApple ComputerLogsCrashReporterMobileDevice&lt;DEVICE_NAME&gt;<br>Windows Vista or 7:  C:Users<username>AppDataRoamingApple ComputerLogsCrashReporterMobileDevice&lt;DEVICE_NAME&gt;</username></username></p>
<h4 id="解析crash-logs"><a href="#解析crash-logs" class="headerlink" title="解析crash logs"></a>解析crash logs</h4><p>Step 1:首先创建一个文件夹，把拿到的崩溃log放进去。</p>
<p>Step 2:再找到symbolicatecrash，Xcode6.0之后位置改成 “Contents/SharedFrameworks”<br>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</p>
<p>实在找不到可以打开终端输入 find /Applications/Xcode.app -name symbolicatecrash -type f ，然后终端会返回这个文件的路径<br>只要找到”symbolicatecrash” 文件, 复制然后粘贴到刚才创建的 “CrashReport” 文件夹里面.</p>
<p>Step 3: 从Xcode Archive的二进制文件中找到.dSYM文件和.app文件拷贝到刚才创建的 “CrashReport” 文件夹里面.</p>
<p>Step 4:打开终端进入CrashReport文件夹，依次输入以下命令行:<br>cd /Users/username/Desktop/CrashReport<br>export DEVELOPER_DIR=/Applications/XCode.app/Contents/Developer<br>./symbolicatecrash ./<em>.crash ./</em>.app.dSYM &gt; symbol.crash<br>这时候终端将会进行处理……<br>处理结果是生成一个新的文件symbol.crash。然后打开这个文件。</p>
<h4 id="分析logs定位崩溃"><a href="#分析logs定位崩溃" class="headerlink" title="分析logs定位崩溃"></a>分析logs定位崩溃</h4><h6 id="崩溃日志的解读："><a href="#崩溃日志的解读：" class="headerlink" title="崩溃日志的解读："></a>崩溃日志的解读：</h6><h6 id="1-进程信息"><a href="#1-进程信息" class="headerlink" title="(1) 进程信息"></a>(1) <strong>进程信息</strong></h6><p>第一部分是闪退进程的相关信息。 </p>
<pre><code>Incident Identifier: 9E634A79-C69B-440D-9A44-5D6A58E196DA
CrashReporter Key:   32786e88d326dd7c5c562760f12bd2826916cad2
Hardware Model:      iPhone7,2
Process:             secondHand [5025]
Path:                /private/var/mobile/Containers/Bundle/Application/52F913A2-001A-4177-A5EC-D1BD743CCC31/secondHand.app/secondHand
Identifier:          com.suning.fanfan
Version:             1.0.0.1 (1.0.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]
</code></pre><p>Incident Identifier是崩溃报告的唯一标识符。<br>CrashReporter Key 是与设备标识相对应的唯一键值。虽然它不是真正的设备唯一标识符，但也是一个非常有用的信息，如果你看到100个崩溃日志的CrashReporter Key值都是相同的，或者只有少数不同的CrashReport值，那说明这不是一个普遍的问题，这个崩溃只发生在了一个或少数几个设备上。Hardware Model 标识设备类型。 如果大部分崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是iPhone6 plus。iPhone6是第七代iPhone，iPhone7.2是第七代iPhone的类型，iPhone6和iPhone6 Plus的类型分别是7.1和7.2。Process 是应用名称。中括号里面的数字是闪退时应用的进程ID。 Path 是app的位置.Identifier 数应用的boundle id。Code Type是手机设置的系统架构，这个是ARM-64。 </p>
<h6 id="2-基本信息"><a href="#2-基本信息" class="headerlink" title="(2) 基本信息"></a>(2) <strong>基本信息</strong></h6><p>这部分给出了一些基本信息，包括闪退发生的日期和时间，设备的iOS版本。如果有很多崩溃日志都来自iOS8.0，说明问题只发生在iOS8.0上。 </p>
<pre><code>Date/Time:           2016-08-12 14:44:38.262 +0800
Launch Time:         2016-08-12 14:44:35.559 +0800
OS Version:          iOS 8.1.2 (12B440)
Report Version:      105 
</code></pre><h6 id="3-异常"><a href="#3-异常" class="headerlink" title="(3) 异常"></a>(3) <strong>异常</strong></h6><p>在这部分，可以看到闪退发生时，抛出的异常类型。还能看到异常编码Exception Codes，和抛出异常的线程Thread。根据崩溃报告类型的不同，还有一些其它的信息。 </p>
<pre><code>Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  0

Last Exception Backtrace:
(0x186e4259c 0x1975980e4 0x186e42220 0x187c4db10 0x10014cf80 0x10014c60c 0x10014bdd0 0x10014ba44 0x10014bc80 0x18b628d34 0x18b611e48 0x18b6286d0 0x18b62835c 0x18b6218b0 0x18b5f4fa8 0x18b893f58 0x18b5f3510 0x186dfa9ec 0x186df9c90 0x186df7d40 0x186d250a4 0x18fec75a4 0x18b65a3c0 0x100187c88 0x197c06a08)
</code></pre><h6 id="4-线程回溯"><a href="#4-线程回溯" class="headerlink" title="(4) 线程回溯"></a>(4) 线程回溯</h6><p>这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。看下面这行日志。 </p>
<pre><code>7   AFNetworking                      0x00000001009601c4 0x100954000 + 49604
</code></pre><p>它包括四列: </p>
<p>帧编号:7 </p>
<p>二进制库的名称:AFNetworking </p>
<p>调用方法的地址:0x00000001009601c4 </p>
<p>第四列分为两个子列，一个基本地址和一个偏移量。0x100954000 + 49604, 第一个数字指向文件，第二个数字指向文件中的代码行。 </p>
<h6 id="5-线程状态"><a href="#5-线程状态" class="headerlink" title="(5) 线程状态"></a>(5) 线程状态</h6><p>这部分是闪退时寄存器中的值。一般不需要这部分的信息，因为回溯部分的信息已经足够让你找出问题所在。 </p>
<pre><code>Thread 0 crashed with ARM Thread State (64-bit):
x0: 0x0000000000000000   x1: 0x0000000000000000   x2: 0x0000000000000000   x3: 0x00000001702e03b7
x4: 0x0000000196d89dfd   x5: 0x000000016fd77400   x6: 0x000000000000006e   x7: 0x0000000000000f80
x8: 0x0000000008000000   x9: 0x0000000004000000  x10: 0x0000000000000200  x11: 0x0000000000000000
</code></pre><h6 id="6-二进制映像"><a href="#6-二进制映像" class="headerlink" title="(6) 二进制映像"></a>(6) 二进制映像</h6><p>这部分列出了闪退时已经加载的二进制文件。 </p>
<pre><code>Binary Images:
0x100088000 - 0x100723fff secondHand arm64  &lt;c8687c8084e13dd5af5c3a56822cca91&gt; /var/mobile/Containers/Bundle/Application/52F913A2-001A-4177-A5EC-D1BD743CCC31/secondHand.app/secondHand
0x100954000 - 0x100987fff AFNetworking arm64  &lt;67843cd1f10431e086a5e163e9085ca1&gt; /var/mobile/Containers/Bundle/Application/52F913A2-001A-4177-A5EC-D1BD743CCC31/secondHand.app/Frameworks/AFNetworking.framework/AFNetworking 
</code></pre><h5 id="崩溃日志符号化（Symbolication）："><a href="#崩溃日志符号化（Symbolication）：" class="headerlink" title="崩溃日志符号化（Symbolication）："></a>崩溃日志符号化（Symbolication）：</h5><p>上面列出的是我们所拿到的原始的崩溃日志的信息，仅仅看二进制库的基本地址和偏移量，我们很难定位到崩溃，所以我们接下来还要进行下一个步骤，那就是符号化——将这些十六进制地址转化成方法名称和行数的过程。 </p>
<p>从Xcode/Organizer获取崩溃日志后过几秒钟，崩溃日志将被自动符号化。Xcode符号化崩溃日志时，需要访问与App Store上对应的应用二进制文件以及生成二进制文件时产生的 .dSYM 文件。必需完全匹配才行。否则，日志将无法被完全符号化。这就要求我们在提交appstore后，务必保留我们最后提交的包，以及它的.dSYM文件，以便后面我们进行符号化。下面是符号化后的样式： </p>
<p>原崩溃文件： </p>
<pre><code>7   libc++abi.dylib                   0x0000000196d85738 0x196d68000 + 120632
8   libobjc.A.dylib                   0x0000000197598290 0x197590000 + 33424
</code></pre><p>转化后： </p>
<pre><code>Last Exception Backtrace:
0   CoreFoundation                    0x186e4259c __exceptionPreprocess + 132
1   libobjc.A.dylib                   0x1975980e4 objc_exception_throw + 60
2   CoreFoundation                    0x186e42220 -[NSException raise] + 12
3   Foundation                        0x187c4db10 -[NSObject(NSKeyValueCoding) setValue:forKey:] + 248
4   secondHand                        0x10014cf80 -[SHTabbarReleaseController alertController] (SHTabbarReleaseController.m:382)
5   secondHand                        0x10014c60c -[SHTabbarReleaseController showSuccessView] (SHTabbarReleaseController.m:300)
</code></pre><h5 id="《翻翻》崩溃日志解读实战："><a href="#《翻翻》崩溃日志解读实战：" class="headerlink" title="《翻翻》崩溃日志解读实战："></a>《翻翻》崩溃日志解读实战：</h5><p>先看下面的崩溃日志，它是应用《翻翻》在1.0.0上线后，在8.0系统上拿到的崩溃日志，并进行了符号化： </p>
<pre><code>Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  0

Last Exception Backtrace:
0   CoreFoundation                    0x186e4259c __exceptionPreprocess + 132
1   libobjc.A.dylib                   0x1975980e4 objc_exception_throw + 60
2   CoreFoundation                    0x186e42220 -[NSException raise] + 12
3   Foundation                        0x187c4db10 -[NSObject(NSKeyValueCoding)     setValue:forKey:] + 248
4   secondHand                        0x10014cf80 -[SHTabbarReleaseController     alertController] (SHTabbarReleaseController.m:382)
5   secondHand                        0x10014c60c -[SHTabbarReleaseController showSuccessView] (SHTabbarReleaseController.m:300)
6   secondHand                        0x10014bdd0 __41-[SHTabbarReleaseController clickPublish]_block_invoke.103 (SHTabbarReleaseController.m:157)
7   secondHand                        0x10014ba44 -[SHTabbarReleaseController checkLoginWithLoginedBlock:loginCancelBlock:] (SHTabbarReleaseController.m:136)
8   secondHand                        0x10014bc80 -[SHTabbarReleaseController clickPublish] (SHTabbarReleaseController.m:154)
9   UIKit                             0x18b628d34 -[UIApplication sendAction:to:from:forEvent:] + 96
10  UIKit                             0x18b611e48 -[UIControl _sendActionsForEvents:withEvent:] + 612
11  UIKit                             0x18b6286d0 -[UIControl touchesEnded:withEvent:] + 592
12  UIKit                             0x18b62835c -[UIWindow _sendTouchesForEvent:] + 700
13  UIKit                             0x18b6218b0 -[UIWindow sendEvent:] + 684
14  UIKit                             0x18b5f4fa8 -[UIApplication sendEvent:] + 264
15  UIKit                             0x18b893f58 _UIApplicationHandleEventFromQueueEvent + 14992
16  UIKit                             0x18b5f3510 _UIApplicationHandleEventQueue + 1616
17  CoreFoundation                    0x186dfa9ec __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24
18  CoreFoundation                    0x186df9c90 __CFRunLoopDoSources0 + 264
19  CoreFoundation                    0x186df7d40 __CFRunLoopRun + 712
20  CoreFoundation                    0x186d250a4 CFRunLoopRunSpecific + 396
21  GraphicsServices                  0x18fec75a4 GSEventRunModal + 168
22  UIKit                             0x18b65a3c0 UIApplicationMain + 1488
23  secondHand                        0x100187c88 main (main.m:14)
24  libdyld.dylib                     0x197c06a08 start + 4
</code></pre><p>找到崩溃日志中问题的方法： </p>
<p>1，看到上图中，异常类型是EXC_CRASH (SIGABRT)， SIGABRT一般是由于某个对象上调用了不存在的方法导致的。EXC_BAD_ACCESS是访问已被释放的内存导致。我们猜测这里可能是发送了unrecogized的方法导致。如果有具体的崩溃原因，会写在Exception Codes的下面。 </p>
<p>2，接着往下看，我们一般从下往上读回溯日志。frame：24是最先调用的，因为它后面写着start +。可以先忽略掉系统库和框架。跟应用源代码相关的帧是最重要的，然后我们定位到frame 4   secondHand                        0x10014cf80 -[SHTabbarReleaseController     alertController] (SHTabbarReleaseController.m:382，在执行它的第382行的代码的时候闪退的。打开Xcode定位到那行代码，这里看到的是在ios8中调用了一个ios9以后才有的方法，导致的崩溃。 </p>

	
	</div>
  <a type="button" href="/2016/10/15/符号化IOS崩溃日志，解读堆栈信息/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/09/22/IOS中的Webview与JS交互方式，以及webkit/">UIWebView与Js的三种交互方式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-09-22  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="UIWebView与Js的三种交互方式"><a href="#UIWebView与Js的三种交互方式" class="headerlink" title="UIWebView与Js的三种交互方式"></a>UIWebView与Js的三种交互方式</h3><h5 id="浏览器内核——WebKit"><a href="#浏览器内核——WebKit" class="headerlink" title="浏览器内核——WebKit"></a>浏览器内核——WebKit</h5><p><strong>webkit介绍</strong> </p>
<p>webkit是一个开源的浏览器框架，safari是在这个基础上开发的，它后面又做了大量的优化改进工作，webkit可以理解为一个排版引擎，除了它之外，浏览器还需要外壳UI，读取网络数据用的CURL库，LibPng/LibJpg图形处理，SQLitx小型关系数据库，js解析引擎，移植层有GUI、FileSystom、Thread、Text等。</p>
<p><strong>webkit的整个工作流程：</strong> </p>
<p>当用户在浏览器输入网址，会把url传给CURL库，CURL负责发布http请求（webkit是排版引擎，网页数据的请求与接收是通过第三方库libcurl处理的，用到GET、POST、PUT、COOKIE的管理、http协议、https协议，本地文件缓存）。 </p>
<h5 id="↓"><a href="#↓" class="headerlink" title="↓"></a>↓</h5><p>得到数据后，传给loader，开始解析，通过dom builder按HTML的规范生成Dom数。 </p>
<h5 id="↓-1"><a href="#↓-1" class="headerlink" title="↓"></a>↓</h5><p>若有JavaScript，JSEnjine会完善dom数，生成dom树的同时，生成render树 </p>
<h5 id="↓-2"><a href="#↓-2" class="headerlink" title="↓"></a>↓</h5><p>调用完成后，调用layout排版，并最终展示出来 </p>
<p><strong>名词解释： </strong><br>Dom：HTML词/语法分析，Dom节点及Render节点创建，会形成Dom熟。</p>
<p>浏览器核心分为两大部分：渲染引擎和Javascript引擎，前者用于处理页面布局，渲染及DOM结构，后者用于JavaScript的解析、执行及DOM交互。JavaScriptCore是一种JavaScript引擎，主要为webkit提供处理能力，safari使用的是这种内核。<br>为什么苹果在ios7以后引入了JavaScript，首先它脱离了浏览器外壳和繁重的ui布局，以及渲染的javascript引擎，可以将js更轻便和更高性能的带给原生应用，无论是移动端还是pc得浏览器，ui和gui都是最重要的性能瓶颈和优化点。</p>
<h4 id="IOS与H5交互的方案，有以下几种："><a href="#IOS与H5交互的方案，有以下几种：" class="headerlink" title="IOS与H5交互的方案，有以下几种："></a>IOS与H5交互的方案，有以下几种：</h4><h5 id="1，使用UIWebView的代理"><a href="#1，使用UIWebView的代理" class="headerlink" title="1，使用UIWebView的代理"></a>1，使用UIWebView的代理</h5><p>js调用obc，需要利用webview的代理，拦截js的网络请求的url scheme与native进行交互，需要处理url及拦截后obc要做的功能。obc调用js，可以通过webview的stringByEvaluatingJavaScriptFromString方法调用js代码。</p>
<h5 id="2，使用JavaScriptCore-framework"><a href="#2，使用JavaScriptCore-framework" class="headerlink" title="2，使用JavaScriptCore.framework"></a>2，使用JavaScriptCore.framework</h5><p>JavaScriptCore.framework是ios7以后推出的框架，它是开源Webkit的一个部分，是一种JavaScript引擎，可以提供脚本处理能力。苹果为我们推出了JavaScriptCore这个框架，为大家在与js交互上提供了很大帮助。JavaScriptCore框架中经常使用的类有：<br>JSContext，</p>
<p>WebViewJavascriptBridge用于支持native的ios与JavaScript交互， </p>
<pre><code>#import &quot;ViewController.h&quot;
#import &lt;JavaScriptCore/JavaScriptCore.h&gt;

@interface ViewController ()&lt;UIWebViewDelegate&gt;
@property(nonatomic,strong)UIWebView * web;
@property(nonatomic,strong)JSContext * context;
@end

@implementation ViewController

- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.

_web = [[UIWebView alloc] init];
_web.delegate = self;

}

-(void)webViewDidFinishLoad:(UIWebView *)webView
{
// html中的调用
//function JSCallOc1(){
//  test1();
//}
//function JSCallOc2(){
//  test2(&apos;带参&apos;,&apos;iOS&apos;);
//}


// 在html中的方法是
//function htTest1(){
//    alert(&quot;OC调用了无参数的js方法&quot;);
//}
//function htTest2(name,num){
//    alert(name+num);
//}


// 1,获取js的上下文
_context = [_web valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

// js调用原生代码，无参
_context[@&quot;test&quot;] = ^(){
    [self method1];
};

// js调用原生代码，有参
_context[@&quot;test2&quot;] = ^(){
    NSArray * args = [JSContext currentArguments];
    NSString * arg1 = args[0];
    [self method2:arg1];
};

// 原生调用js的方法,无参
[_web stringByEvaluatingJavaScriptFromString:@&quot;htTest1()&quot;];
// 原生调用js的方法,有参
[_web stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;htTest2(%@,%@)&quot;,@&quot;1&quot;,@&quot;2&quot;]];

// 自己定义js调用
NSString *alertJS=@&quot;alert(&apos;test‘)&quot;; //准备执行的js代码
[_context evaluateScript:alertJS];
}

-(void)method1
{

}

-(void)method2:(NSString *)arg
{

}
</code></pre><h5 id="3，使用WebViewJavascriptBridge"><a href="#3，使用WebViewJavascriptBridge" class="headerlink" title="3，使用WebViewJavascriptBridge"></a>3，使用WebViewJavascriptBridge</h5><p>WebViewJavascriptBridge是Obj-C和JavaScript通过UIWebViews/WebViews互通消息的一个iOS/OSX的桥梁，它并没有直接代理来实现，而是这样：</p>
<pre><code>- (void)viewWillAppear:(BOOL)animated {
if (_bridge) { return; }

UIWebView* webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, 320, 400)];
[self.view addSubview:webView];
//开启调试信息
[WebViewJavascriptBridge enableLogging]; 

//响应JS通过send发送给OC的消息
_bridge = [WebViewJavascriptBridge bridgeForWebView:webView webViewDelegate:self handler:^(id data, WVJBResponseCallback responseCallback) {
 NSLog(@&quot;ObjC received message from JS: %@&quot;, data);
responseCallback(@&quot;Response for message from ObjC&quot;);
}]; 

//响应JS通过callhandler发送给OC的消息
[_bridge registerHandler:@&quot;testObjcCallback&quot; handler:^(id data, WVJBResponseCallback responseCallback) {
NSLog(@&quot;testObjcCallback called: %@&quot;, data);
responseCallback(@&quot;Response from testObjcCallback&quot;);
}];
[self renderButtons:webView];
[self loadExamplePage:webView];
} 
</code></pre><p>这个框架定义了两种OC与JS之间通信的方式，一种是send，发送一条消息，另一种是通过一个key调用callHandler，这两个方法接收js返回的data并显示，之后再调用responseCallback方法，回调js的代码。这是OC响应JS发来的消息。当然也可以OC主动给JS发消息。 </p>
<pre><code>//OC调用send给JS发消息
- (void)sendMessage:(id)sender {
[_bridge send:@&quot;A string sent from ObjC to JS&quot; responseCallback:^(id response) {
 NSLog(@&quot;sendMessage got response: %@&quot;, response);
}];
}
//OC调用callHandler给JS发消息
- (void)callHandler:(id)sender {
 id data = @{ @&quot;greetingFromObjC&quot;: @&quot;Hi there, JS!&quot; };
[_bridge callHandler:@&quot;testJavascriptHandler&quot; data:data responseCallback:^(id response) {
 NSLog(@&quot;testJavascriptHandler responded: %@&quot;, response);
}];
</code></pre><p>其中在JS端，可以有多个handler，所以callHandler需要一个key来寻找指定方法。responseCallback用于响应JS处理完毕后对OC的回调。</p>

	
	</div>
  <a type="button" href="/2016/09/22/IOS中的Webview与JS交互方式，以及webkit/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/09/21/IOS中的切图规范及尺寸要求md/">IOS中的切图规范及尺寸要求</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-09-21  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>IOS中的切图规范及尺寸要求md</p>
<p>1． 文件格式：ios统一使用PNG格式图片文件。 </p>
<p>2． 尺寸分三种：1x、2x、3x，分别命名为 .png  @2x.pgn  @3x.png。 </p>
<p>注：1x是为非retain屏幕准备的图片，现只有iphone4以下的手机和ipad一代使用1x，可忽略，retain的屏幕需要加@2x或者@3x，1280为基准的需要加@3x。 </p>
<p>3． 按照切图类型命名： </p>
<p>背景:bg_home_xx.png </p>
<p>按钮:按钮一般有三种状态，普通状态、选中状态、不可点击状态，分别可以btn_xx_normal.png、btn_xx_hlight.png、btn_xx_disable.png命名，或使用简称btn_xx_n.png、btn_xx_h.png、btn_xx_d.png。对于复选的按钮有两种状态，普通状态和选中的状态，可命名为btn_xx_normal.png和btn_xx_selected.png。 </p>
<p>普通图标：icon_product_detail_xx.png     </p>
<p>图片和照片:可命名为img_xx.png或pic_xx.png </p>
<p>导航栏图片：nav_xx.png </p>
<p>底部导航栏:tab_xx.png </p>
<p>4, 不要以数字和符号作为开头。 </p>
<p>5．引导图，iPhone手机客户端引导页有四种尺寸，分别是640<em>960、640</em>1136、750<em>1334、1242</em>2208，命名时固定为HELPER_1，HELPER_1_568,HELPER_1_667,HELPER_1_1104，_1_代表第几张引导图。 </p>
<p>ipad引导图尺寸为：1024 x 768 。 </p>
<p>6． icon图：需要6张图，分别是58<em>58(命名为<a href="mailto:29X29@2x.png" target="_blank" rel="noopener">29X29@2x.png</a>)，87</em>87(命名为<a href="mailto:87X87@3x.png" target="_blank" rel="noopener">87X87@3x.png</a>)，80<em>80(命名为<a href="mailto:80X80@2x.png" target="_blank" rel="noopener">80X80@2x.png</a>)，120</em>120（命名为<a href="mailto:120X120@2x.png" target="_blank" rel="noopener">120X120@2x.png</a>和<a href="mailto:120X120@3x.png" target="_blank" rel="noopener">120X120@3x.png</a>分别存两张），180*180（命名为<a href="mailto:180X180@3x.png" target="_blank" rel="noopener">180X180@3x.png</a>）。 </p>
<p>7,  App Store图尺寸，需要一张1024<em>1024尺寸ICON，其分辨率要大于72DPI。预览图需要四个尺寸：640</em>960、640<em>1136、750</em>1334、1242*2208。 </p>
<p>8． 标注图：可按照iphone6的尺寸标注，其它尺寸若需要适配，可单独出标注图。例如iphone4s和iphone6+的尺寸差距较大，哪些元素在适配时需要等比例缩放，哪些尺寸不变而要调整位置，可单独标注。</p>

	
	</div>
  <a type="button" href="/2016/09/21/IOS中的切图规范及尺寸要求md/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/09/20/IOS应用的生命周期、Tableview的生命周期及优化整理/">IOS生命周期、Tableview生命周期及优化方案</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-09-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="IOS生命周期、Tableview生命周期及优化方案"><a href="#IOS生命周期、Tableview生命周期及优化方案" class="headerlink" title="IOS生命周期、Tableview生命周期及优化方案"></a>IOS生命周期、Tableview生命周期及优化方案</h2><h4 id="IOS应用的生命周期"><a href="#IOS应用的生命周期" class="headerlink" title="IOS应用的生命周期"></a>IOS应用的生命周期</h4><p>1，点击 app icon 或者从应用程序url（比如在Safari地址栏中输入应用程序url）启动应用程序。</p>
<p>2，就会进入 UIApplicationDelegate 的 - (void)applicationDidFinishLaunching:(UIApplication <em>)application;<br>或- (BOOL)application:(UIApplication </em>)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;</p>
<p>3, 如果是从 url 启动的则先进入 UIApplicationDelegate 的- (BOOL)application:(UIApplication <em>)application handleOpenURL:(NSURL </em>)url;</p>
<p>4，进入 UIApplicationDelegate 的- (void)applicationDidBecomeActive:(UIApplication *)application;</p>
<p>5，进入应用程序主循环，这时应用程序已经是活动的了，用户可以与应用程序交互。</p>
<p>6，应用程序被中断，如来电、短信，进入 UIApplicationDelegate 的- (void)applicationWillResignActive:(UIApplication *)application;<br>如果用户选择不处理继续留在当前应用程序，则回到Active。</p>
<p>7，进入 UIApplicationDelegate 的- (void)applicationWillTerminate:(UIApplication *)application;当前应用程序关闭。</p>
<h4 id="ViewController的生命周期"><a href="#ViewController的生命周期" class="headerlink" title="ViewController的生命周期"></a>ViewController的生命周期</h4><h6 id="1，alloc："><a href="#1，alloc：" class="headerlink" title="1，alloc："></a>1，alloc：</h6><p>创建对象，分配空间。init：初始化方法，初始化对象，初始化数据。</p>
<h6 id="2，loadView"><a href="#2，loadView" class="headerlink" title="2，loadView"></a>2，loadView</h6><p>每次访问viewcontroller的View的getter方法，如ontroller.view,而且view为nil，loadview会被调用。如果视图需要显示在屏幕上，就会调用loadView方法创建视图。用于给我们自定义UIViewController的view用的。</p>
<h6 id="3，ViewDidLoad"><a href="#3，ViewDidLoad" class="headerlink" title="3，ViewDidLoad"></a>3，ViewDidLoad</h6><p>无论是通过xib还是重写loadView创建VC的view，view创建完毕，最终都会调用ViewDidLoad。视图载入完成，在这里可以进行加子视图、从数据库或者网络加载模型数据展示到视图中。</p>
<h6 id="4，ViewDidUnLoad"><a href="#4，ViewDidUnLoad" class="headerlink" title="4，ViewDidUnLoad"></a>4，ViewDidUnLoad</h6><p>当发出内存警告且view被释放的时候就会调用ViewDidUnLoad，所以一般在这个方法里释放一些不用的视图资源。dealloc是在释放UIViewController的时候调用的，释放view时没有调用。</p>
<h6 id="5，viewWillAppear"><a href="#5，viewWillAppear" class="headerlink" title="5，viewWillAppear"></a>5，viewWillAppear</h6><p>视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了</p>
<h6 id="6，viewDidAppear"><a href="#6，viewDidAppear" class="headerlink" title="6，viewDidAppear"></a>6，viewDidAppear</h6><p>视图已在屏幕上渲染完成  </p>
<p>整个的顺序为：运行app-&gt;载入视图-&gt;调用ViewDidLoad-&gt;viewWillAppear-&gt;viewDidAppear-&gt;运行</p>
<h3 id="一个视图被移除屏幕并且销毁的时候的执行顺序"><a href="#一个视图被移除屏幕并且销毁的时候的执行顺序" class="headerlink" title="一个视图被移除屏幕并且销毁的时候的执行顺序"></a>一个视图被移除屏幕并且销毁的时候的执行顺序</h3><h6 id="1、viewWillDisappear"><a href="#1、viewWillDisappear" class="headerlink" title="1、viewWillDisappear"></a>1、viewWillDisappear</h6><p>视图将被从屏幕上移除之前执行</p>
<h6 id="2、viewDidDisappear"><a href="#2、viewDidDisappear" class="headerlink" title="2、viewDidDisappear"></a>2、viewDidDisappear</h6><p>视图已经被从屏幕上移除，用户看不到这个视图了</p>
<h6 id="3、dealloc"><a href="#3、dealloc" class="headerlink" title="3、dealloc"></a>3、dealloc</h6><p>视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放</p>
<h4 id="为什么要重写UIView的initWithFrame：方法而不是init方法"><a href="#为什么要重写UIView的initWithFrame：方法而不是init方法" class="headerlink" title="为什么要重写UIView的initWithFrame：方法而不是init方法"></a>为什么要重写UIView的initWithFrame：方法而不是init方法</h4><p>1，因为在init方法的时候，也调用了initwithframe方法，我们不确定别的同事在调用我们方法的时候，是直接调用的initwithframe方法，这样在init方法中添加的视图可能就没有了。 </p>
<p>2，在构造方法里面直接取self.frame是不准的，这个时候可能还没有赋值frame，只能在里面先添加。在layoutSubViews方法中可以设置准确的宽高。 </p>
<p>3，initWithFrame只有在用代码创建的时候会调用，用xib调用的时候，会调用initWithCoder。</p>
<h3 id="如何设计良好的viewController"><a href="#如何设计良好的viewController" class="headerlink" title="如何设计良好的viewController"></a>如何设计良好的viewController</h3><p>init里不要出现创建view的代码，良好的设计在init里应该只有相关数据的初始化， </p>
<p>init不要调self.view否则会导致viewcontroller创建view，因为view是懒加载的。 </p>
<p>loadview中只初始化view，在调用[super loadview]之前不可调用view的getter方法，不建议重载这个方法。</p>
<p>viewdidload里面view已经有了，适合创建一些附加的view，但是注意viewdidload会调用多次。</p>
<h4 id="TableView回调方法的执行顺序："><a href="#TableView回调方法的执行顺序：" class="headerlink" title="TableView回调方法的执行顺序："></a>TableView回调方法的执行顺序：</h4><p>UITableView的回调顺序是： </p>
<p>1，共有多少个Cell，就调用多少次tableView:heightForRowAtIndexPath:以确定ContentSize及Cell的位置。 </p>
<p>2，然后当前屏幕显示多少个，就调用几次tableView:cellForRowAtIndexPath来显示Cell。 </p>
<p>3，滚动屏幕时，每当Cell滚入屏幕，都会调用一次tableView:heightForRowAtIndexPath和tableView:cellForRowAtIndexPath方法。 </p>
<h3 id="如何做tableview的优化"><a href="#如何做tableview的优化" class="headerlink" title="如何做tableview的优化"></a>如何做tableview的优化</h3><p>1，回调方法各负其职。提前计算并缓存好高度，因为tableView:heightForRowAtIndexPath会被频繁的调用。   </p>
<p>2，UITableView最核心的思想就是UITableViewCell的重用机制，简单的理解就是，UITableView只会创建一屏幕的UITableViewCell，其它都是从一个集合中取出来重用的，每当Cell滑出屏幕时，就会放到这个集合中（重用池），当要显示一个cell时，去重用池中找，如果有就直接拿来显示，没有才会创建，这样做的好处会极大的减少内存的开销。</p>
<pre><code>static NSString *CellIdentifier = @&quot;xxx&quot;;
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil) {
cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
}
</code></pre><p>3，继承UITableViewCell，并在drawRect自行绘制图像和text。我们在Cell上添加控件，实质上都是要调用底层的接口进行绘制，大量的添加控件对资源的开销也很大，不如直接绘制。如果我们重写Cell中的drawRect方法，就不需要GCD异步线程了，因为drawRect本身就是异步绘制的。使用不透明的视图可以极大地提高渲染的速度，，设置cell及其子视图的opaque属性设为YES/alpha为1，例如不要使用clearColor。当一个view是透明的，IOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多的subview，这是一个非常耗时的过程。</p>
<p>4，如果不是需要动画效果，做好不要使用insertRowsAtIndexPaths，而使用reloadData，因为insertRowsAtIndexPaths会调用所有的cellForRow方法，即便不需要cell也会创建大量多余的cell。 </p>
<p>5，按需加载，在大量图片展示和网路而加载的时候很管用。自动更新数据是用户友好的一种方式，减少了用户等待下载的时候，如果每次载入100条信息，就可以在滚动到倒数20条的时候，加载更多的内容。</p>
<p>6，在更新数据的时候界面卡住，原因是主线程执行了耗时很长的函数方法，应该使用多线程进行异步加载，让子线程去执行这些函数或方法。这里面还有一个问题，当下载线程数超过2个时，会显著影响主线程的性能。因此在使用 ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其 maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。<br>在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度： </p>
<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {
if (!decelerate) {
queue.maxConcurrentOperationCount = 5;
}
}
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {
queue.maxConcurrentOperationCount = 5;
}
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
queue.maxConcurrentOperationCount = 2;
} 
</code></pre><p>7，heightForRowAtIndexPath中尽量不使用cellForRowAtIndexPath，如果需要用，只使用一次并缓存结果。tableView:heightForRowAtIndexPath的回调中，计算高度使用了UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath]，如果有1000个cell，它就会调用一千次，重叠代码会影响性能。 </p>
<p>8，尽量少给cell动态添加view，addsubview，可以初始化的时候就添加，然后通过hide来控制是否显示。注意的是，cell被重用时，他内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect。</p>

	
	</div>
  <a type="button" href="/2016/09/20/IOS应用的生命周期、Tableview的生命周期及优化整理/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/09/20/移动端的socket通信/">移动端的socket通信</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-09-20  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="实现移动端的socket通信"><a href="#实现移动端的socket通信" class="headerlink" title="实现移动端的socket通信"></a>实现移动端的socket通信</h1><p>socket在英文中的意思是“插座”，顾名思义，插座上的孔就是端口号，我们用socket实现不同计算机之间的通信，而端口对应不同的服务。socket的本质上是编程的API，是对TCP/IP的封装。 </p>
<p>一般我们在两个客户端发送消息的过程是，首先打开一个和对方链接的socket，往里面写数据，要是socket里面有数据，就读出来，这就是最简单的网络编程。 </p>
<p>1，socket连接 </p>
<p>我们一般使用socket来实现即时通讯，因为它的特点就是实时性，但需要对socket的连接进行监视与检测，在断线时重新连接，在登录和退出的操作里，要手动的打开或者关闭，不要对已经连接的socket对象再次进行连接操作，打开时先判断连接状态。 </p>
<p>2，心跳检测 </p>
<p>使用socket通讯还有一个必须的操作，就是对服务器发送心跳检测，每隔一段时间发送长连接指令，如果没有收到服务器返回的消息，AsyncSocket会得到失去连接的消息，我们要在失去连接的回调方法里重新连接。连接时需要的host与port都是由服务器指定。我们在程序中可以创建一个计时器，比如每隔30s时间发送心跳包。 </p>
<p>3，断开连接 </p>
<p>断开连接有服务器断开和主动断开两种情况，主动断开一般是因为退出登录或是程序退出等。如果是服务器掉线，我们要进行重连。 </p>
<h3 id="使用CocoaAsyncSocket进行socket连接"><a href="#使用CocoaAsyncSocket进行socket连接" class="headerlink" title="使用CocoaAsyncSocket进行socket连接"></a>使用CocoaAsyncSocket进行socket连接</h3><h5 id="1，创建GCDAsyncSocket对象"><a href="#1，创建GCDAsyncSocket对象" class="headerlink" title="1，创建GCDAsyncSocket对象"></a>1，创建GCDAsyncSocket对象</h5><p>首先我们来创建一个GCDAsyncSocket对象，可以理解它为一个socket套接字，我们的操作都是针对于这个socket执行的各种命令，可以打开一个端口侦听，同样也可以连接其它计算机的端口进行通讯等等。 </p>
<p>在创建方法中，有两个参数，一个是设置委托对象，也就是参数中的self，以及一个运行的GCD消息队列，这里使用的是全局队列。创建完GCDAsyncSocket，我们的socket就已经加到程序中以供使用了。</p>
<pre><code>-(GCDAsyncSocket *)socket
{
if (_socket == nil) {
    _socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];
}

return _socket;
} 
</code></pre><h5 id="2，建立连接"><a href="#2，建立连接" class="headerlink" title="2，建立连接"></a>2，建立连接</h5><p>以前我们使用http连接的时候（NSURLRequest），可以直接指定服务器和端口号，但是对socket来说，它的作用不只是与服务器进行通讯，socket还需要侦听端口来等待别人的连接，所以我们使用socket套接字编程，是从http协议过渡到tcp协议的一个转变。</p>
<pre><code>[self.socket connectToHost:host onPort:port error:&amp;err];
</code></pre><p>关闭连接</p>
<pre><code>-(void)close
{
[self.socket disconnect];
[self.socket setDelegate:nil];
self.socket = nil;
}
</code></pre><h5 id="3，准备发送消息"><a href="#3，准备发送消息" class="headerlink" title="3，准备发送消息"></a>3，准备发送消息</h5><p>在下面的程序中，有一个非常重要的方法，就是 ：[_socket writeData:alldata withTimeout:_timeout tag:0];这个方法中有三个参数，一个是我们要发送的数据，一个是超时时间，如果我们设置为-1则认为永不超时，第三个参数tag，可以理解为，我们派了一个编号为tag的员工，负责去等待新的消息，万一我们需要区分他们的时候，就使用tag。  </p>
<p>这里明明是在发送数据，为什么我们要用write，其实这是一个写入的过程，向TCP的通讯流中写入数据。TCP协议是一个基于字节流的传输层通信协议，传输数据的形式也是以流的形式，整个TCP都可以看做是一条无尽的流，我们发送数据就是往里面写入流，读取数据就是取出流，只要流里有数据，我们就可以一直取到，还要注意的是，流式传输数据时，数据不会自己分段，没有起始和结尾之分，如果发送了两段文字，可能收到的是连在一起的文字，为了解决这个问题，我们一般采取一个固定的字节数据组合来区分开头和结尾。</p>
<pre><code>-(BOOL)sendWithData:(NSData *)data andSuccess:(void (^)(NSData *))success andFailure:(void (^)(NSData *, NSError *))failure
{
    NSInteger num = data.length;

// 添加固定的字节数组来分段

Byte bytes[4];

for(int i = 0;i &lt; 4;i++)
{
    bytes[i] = num &gt;&gt; 8 * (3-i) &amp; 0xFF;
}

NSData *rsdata = [NSData dataWithBytes:bytes length:4];

NSMutableData *alldata = [NSMutableData data];

[alldata setData:rsdata];

[alldata appendData:data];

[self addSendData:data andSuccess:success andFailure:failure];

// 真正的发送socket
[_socket writeData:alldata withTimeout:_timeout tag:0];
</code></pre><h5 id="4，GCDAsyncSocket的委托方法"><a href="#4，GCDAsyncSocket的委托方法" class="headerlink" title="4，GCDAsyncSocket的委托方法"></a>4，GCDAsyncSocket的委托方法</h5><p>GCDAsyncSocket类似于我们使用的NSURLConnection，我们通过委托方法来处理一切关于连接之后执行的事情，比如确认连接、发送心跳包，让服务器可以一直确认你的存在，与服务器的传输格式要事先商定好。下面看主要的委托方法：</p>
<pre><code>// 读取数据
- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
 {
 // 转换数据格式
 NSDictionary *newMessage = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
 }

// 发送数据
-(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag
{

[self callBackSendDataWithType:SNYXSocketSendDataCallTypeSuccess];
}
</code></pre>
	
	</div>
  <a type="button" href="/2016/09/20/移动端的socket通信/#more" class="btn btn-default more">Read More</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2016/09/16/一行一行解读SDWebImage实现原理/">一行一行解读SDWebImage实现原理</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2016-09-16  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="一行一行解读SDWebImage实现原理"><a href="#一行一行解读SDWebImage实现原理" class="headerlink" title="一行一行解读SDWebImage实现原理"></a>一行一行解读SDWebImage实现原理</h1><h3 id="SDImageCache是怎么做数据管理的："><a href="#SDImageCache是怎么做数据管理的：" class="headerlink" title="SDImageCache是怎么做数据管理的："></a>SDImageCache是怎么做数据管理的：</h3><p>SDImageCache分两个部分，一个是内存层面的，一个是硬件层面的。<br>内存层面相当是缓存器，以键值的形式存储图片，当内存不够的时候会清除所有的缓存图片。文件替换的方式是以时间为单位，删除时间大于一周的图片文件。当当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有就直接返回，没有的话去访问硬盘，将图片从磁盘读出来，然后解码，放在内存层面做备份，再给调用层。</p>
<p>由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，<br>所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。<br>为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。</p>
<h3 id="SDWebImage-加载图片的流程："><a href="#SDWebImage-加载图片的流程：" class="headerlink" title="SDWebImage 加载图片的流程："></a>SDWebImage 加载图片的流程：</h3><p>占位图-&gt;根据url查找缓存queryDiskCacheForKey-&gt;从硬盘缓存目录下尝试读取图片文件，读取到添加到内存缓存中，回主线程进行操作。如果没有读取到，说明所有的缓存都不存在该图片。-&gt;图片下载由 NSURLConnection,实现其代理方法，connection:didReceiveData: 中利用ImageIO做了按图片下载进度。-&gt;数据下载完成后交给 SDWebImageDecoder做图片解码处理-&gt;解码完成，图片保存到SDImageCache中，内存缓存和硬盘缓存同时保存。-&gt;在收到内存警告时清楚图片缓存，以及在关闭应用时，请出过期图片。</p>
<h3 id="具体流程解析："><a href="#具体流程解析：" class="headerlink" title="具体流程解析："></a>具体流程解析：</h3><p>1，UIImageView+WebCache:  setImageWithURL:placeholderImage:options: 先显示 placeholderImage ，同时由SDWebImageManager 根据 URL来在本地查找图片。</p>
<p>2，SDWebImageManager: downloadWithURL:delegate:options:userInfo: SDWebImageManager是将UIImageView+WebCache同SDImageCache链接起来的类， SDImageCache： queryDiskCacheForKey:delegate:userInfo:用来从缓存根据CacheKey查找图片是否已经在缓存中，如果内存中已经有图片缓存， SDWebImageManager会回调SDImageCacheDelegate:imageCache:didFindImage:forKey:userInfo:，而UIImageView+WebCache 则回调SDWebImageManagerDelegate:  webImageManager:didFinishWithImage:来显示图片。如果内存中没有图片缓存，那么生成 NSInvocationOperation 添加到队列，从硬盘查找图片是否已被下载缓存。</p>
<p>3，根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</p>
<p>4，如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。</p>
<p>5,connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder做图片解码处理。图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</p>
<p>6,在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给SDWebImageDownloader。<br>imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。</p>
<p>7,将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。<br>写文件到硬盘在单独 NSInvocationOperation 中完成，避免拖慢主线程。</p>
<p>8,如果是在iOS上运行，SDImageCache 在初始化的时候会注册notification 到 UIApplicationDidReceiveMemoryWarningNotification 以及  UIApplicationWillTerminateNotification,在内存警告的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>SDWebImagePrefetcher 可以预先下载图片，方便后续使用。<br>通过对UIImageView的类别扩展来实现异步加载替换图片的工作。</p>
<p>主要用到的对象：<br>1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调。 </p>
<p>2、SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。 </p>
<p>向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader 。<br>实现SDImageCache和SDWebImageDownloader的回调。 </p>
<p>3、SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）<br>实现图片和内存清理工作。 </p>
<p>4、SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式）</p>
<p>其他类：<br>SDWebImageDecoder，异步对图像进行了一次解压⋯⋯</p>
<h5 id="图片的缓存类型："><a href="#图片的缓存类型：" class="headerlink" title="图片的缓存类型："></a>图片的缓存类型：</h5><pre><code>typedef NS_ENUM(NSInteger, SDImageCacheType) {
/**
 * The image wasn&apos;t available the SDWebImage caches, but was downloaded from the web.
 该图像是不可用的SDWebImage缓存，但是从网络下载的.
 */
SDImageCacheTypeNone,
/**
 * The image was obtained from the disk cache.
 图像从磁盘高速缓存获得.
 */
SDImageCacheTypeDisk,
/**
 * The image was obtained from the memory cache.
 图像从存储器高速缓存获得
 */
SDImageCacheTypeMemory
};
</code></pre><p>可以直接传入一个NSURL的图片路径对象对图片进行加载，若加载不为空则把图片缓存放入图片管理器单例保存起来，下一次再调用这个方式时会判断URL是否存在去读缓存。</p>
<h2 id="一步一步解析源码（一）"><a href="#一步一步解析源码（一）" class="headerlink" title="一步一步解析源码（一）"></a>一步一步解析源码（一）</h2><h4 id="加载图片的过程："><a href="#加载图片的过程：" class="headerlink" title="加载图片的过程："></a>加载图片的过程：</h4><pre><code>- (void)setImageWithURL:(NSURL *)url refreshCache:(BOOL)refreshCache placeholderImage:(UIImage *)placeholder
{

// Remove in progress downloader from queue

self.image = placeholder;

if (url)
{
    if ([[CustomObject sharedCustomObject] isExistImage:url]) {
        NSLog(@&quot;存在图片&quot;);
        self.image = [[CustomObject sharedCustomObject]getImage:url];
    }
    else{
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSData * data = [[NSData alloc]initWithContentsOfURL:url];
            UIImage *image = [[UIImage alloc]initWithData:data];
            if (data != nil) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [[CustomObject sharedCustomObject] addImage:image key:url];
                    self.image = image;
                });
            }
        });
    }
}
}
</code></pre><h4 id="核心算法：sd-setImageWithURL"><a href="#核心算法：sd-setImageWithURL" class="headerlink" title="核心算法：sd_setImageWithURL"></a>核心算法：sd_setImageWithURL</h4><p><strong>1，</strong>我们最常用的sd_setImageWithURL这个方法，最终都会调用：- sd_setImageWithURL: placeholderImage: options: progress: completed:这个核心算法。现在跟一下这个算法的内部实现：首先执行：</p>
<pre><code>[self sd_cancelCurrentImageLoad];// 移除UIImageview当前绑定的操作，比如当cell被重用时，先执行这行代码，保证它的下载和缓存操作都被取消。
</code></pre><p>它内部的执行是：</p>
<pre><code>- (void)sd_cancelCurrentImageLoad {
[self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];
}
//会调用UIView+WebCacheOperation的
- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key
</code></pre><p><strong>2，</strong>然后看UIView+WebCacheOperation的内部实现</p>
<p>它提供了三个方法用于操作绑定关系，</p>
<pre><code>@interface UIView (WebCacheOperation)

/**
 *  Set the image load operation (storage in a UIView based dictionary)
  *
  *  @param operation the operation
  *  @param key       key for storing the operation
  */
 - (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key;

 /**
  *  Cancel all operations for the current UIView and key
  *
  *  @param key key for identifying the operations
  */
 - (void)sd_cancelImageLoadOperationWithKey:(NSString *)key;

 /**
  *  Just remove the operations corresponding to the current UIView and key without cancelling them
  *
  *  @param key key for identifying the operations
  */
 - (void)sd_removeImageLoadOperationWithKey:(NSString *)key;
</code></pre><p>-(NSMutableDictionary *)operationDictionary用到了&lt;objc/runtime.h&gt;中定义的两个函数:<br>objc_setAssociatedObject和objc_getAssociatedObject</p>
<pre><code>NSObject+AssociatedObject.m
@implementation NSObject (AssociatedObject)
@dynamic associatedObject;
-(void)setAssociatedObject:(id)object{
objc_setAssociatedObject(self, @selector(associatedObject), object,     OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
-(id)associatedObject { 
return objc_getAssociatedObject(self, @selector(associatedObject));
}
</code></pre><p>objc_setAssociatedObject是对已经存在的类在扩展中添加自定义的属性，添加属性的key最好是static char类型的，key应该是唯一的。objc_getAssociatedObject可以根据key获得与对象绑定的属性。这个loadOperationKey的属性是operationDictionary类型的，operationDictionary的value是操作，key是针对不同类型和不同类型的操作设定的字符串。&amp;符号是右操作对象的地址，&amp;operationDictionary返回static char loadOperation的地址。</p>
<pre><code>NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);
if (operations) {
    return operations;
}
</code></pre><p>下面是取消操作的实现，如果可以取到operationDictionary，根据key可以得到与视图相关的操作，取消它们，并根据key值，从operationDictionary里面删除这些操作。</p>
<pre><code>- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key {
// Cancel in progress downloader from queue
NSMutableDictionary *operationDictionary = [self operationDictionary];
id operations = [operationDictionary objectForKey:key];
if (operations) {
    if ([operations isKindOfClass:[NSArray class]]) {
        for (id &lt;SDWebImageOperation&gt; operation in operations) {
            if (operation) {
                [operation cancel];
            }
        }
    } else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)]){
        [(id&lt;SDWebImageOperation&gt;) operations cancel];
    }
    [operationDictionary removeObjectForKey:key];
}
</code></pre><p>}</p>
<p><strong>3，</strong>继续分析开始的核心算法-sd_setImageWithURL: placeholderImage: options: progress: completed</p>
<pre><code>- (void)sd_setImageWithURL:(NSURL *)url
      placeholderImage:(UIImage *)placeholder
               options:(SDWebImageOptions)options
              progress:(SDWebImageDownloaderProgressBlock)progressBlock 
completed:(SDWebImageCompletionBlock)completedBlock {
[self sd_cancelCurrentImageLoad];

//用static char imageURLKey作key，将url作为属性绑定到ImageView上
objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

//options &amp; SDWebImageDelayPlaceholder这是一个位运算的与操作,!(options &amp; SDWebImageDelayPlaceholder)的意思就是options参数不是SDWebImageDelayPlaceholder,就执行以下操作   

#define dispatch_main_async_safe(block)\
if ([NSThread isMainThread]) {\
    block();\
} else {\
    dispatch_async(dispatch_get_main_queue(), block);\
}
</code></pre><p>这是一个宏定义,因为<strong>图像的绘制只能在主线程完成</strong>,所以dispatch_main_sync_safe就是为了保证block在主线程中执行</p>
<pre><code> if (!(options &amp; SDWebImageDelayPlaceholder)) {
    dispatch_main_async_safe(^{
//设置imageView的placeHolder
        self.image = placeholder;
    });
}

if (url) {

    // 检查是否通过setShowActivityIndicatorView:方法设置了显示正在加载指示器。如果设置了，使用`addActivityIndicator`方法向self添加指示器
    if ([self showActivityIndicatorView]) {
        [self addActivityIndicator];
    }

    __weak __typeof(self)wself = self;

//下载的核心方法

    id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options 
progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
      //移除加载指示器
        [wself removeActivityIndicator];
      //如果imageView不存在了就return停止操作
        if (!wself) return;
        dispatch_main_sync_safe(^{
            if (!wself) return;
</code></pre><p>SDWebImageAvoidAutoSetImage,默认情况下图片会在下载完毕后自动添加给imageView,但是有些时候我们想在设置图片之前加一些图片的处理,就要下载成功后去手动设置图片了,不会执行<code>wself.image = image;</code>,而是直接执行完成回调，有用户自己决定如何处理。</p>
<pre><code>if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)
{
    completedBlock(image, error, cacheType, url);
    return;
}
</code></pre><p>如果后两个条件中至少有一个不满足，那么就直接将image赋给当前的imageView<br>，并调用setNeedsLayout</p>
<pre><code>else if (image) {
    wself.image = image;
    [wself setNeedsLayout];
} else {
</code></pre><p>image为空，并且设置了延迟设置占位图，会将占位图设置为最终的image，，并将其标记为需要重新布局。</p>
<pre><code>                if ((options &amp; SDWebImageDelayPlaceholder)) {
                    wself.image = placeholder;
                    [wself setNeedsLayout];
                }
            }
            if (completedBlock &amp;&amp; finished) {
                completedBlock(image, error, cacheType, url);
            }
        });
    }];
 // 为UIImageView绑定新的操作,以为之前把ImageView的操作cancel了
    [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];
} else {
 // 判断url不存在，移除加载指示器，执行完成回调，传递错误信息。
    dispatch_main_async_safe(^{
        [self removeActivityIndicator];
        if (completedBlock) {
            NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@{NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;}];
            completedBlock(nil, error, SDImageCacheTypeNone, url);
        }
    });
}
}
</code></pre><p><strong>4，</strong>SDWenImageManager<br>-sd_setImageWithURL:forState:placeholderImage:options:completed:中,下载图片方法是位于SDWebImageManager类中- downloadImageWithURL: options:progress:completed:。<br>SDWenImageManager的作用,其实UIImageVIew+WebCache这个Category背后执行操作的就是这个SDWebImageManager.它会绑定一个下载器也就是SDwebImageDownloader和一个缓存SDImageCache</p>
<pre><code>第一个参数是必须的,就是image的url
第二个参数options你可以定制化各种各样的操作
第三个参数是一个回调block,用于图片下载过程中的回调
第四个参数是一个下载完成的回调,会在图片下载完成后回调
返回值是一个NSObject类,并且这个NSObject类是遵循一个协议这个协议叫SDWebImageOperation,这个协议里面只写了一个协议,就是一个cancel一个operation的协议/**
 *  Downloads the image at the given URL if not present in cache or return the cached version otherwise.
 *
 *  @deprecated This method has been deprecated. Use `downloadImageWithURL:options:progress:completed:`
 */
- (id &lt;SDWebImageOperation&gt;)downloadWithURL:(NSURL *)url
                                options:(SDWebImageOptions)options
                               progress:(SDWebImageDownloaderProgressBlock)progressBlock
                              completed:(SDWebImageCompletedWithFinishedBlock)completedBlock __deprecated_msg(&quot;Method deprecated. Use `downloadImageWithURL:options:progress:completed:`&quot;);
</code></pre><p><strong>5，缓存策略-SDWebImageOptions</strong></p>
<p>  默认是开启了硬盘\内存缓存的</p>
<ul>
<li><p>SDWebImageRetryFailed   下载失败了会再次尝试下载</p>
</li>
<li><p>SDWebImageLowPriority   当UIScrollView等正在滚动时，延迟下载图片（放置scrollView滚动卡）</p>
</li>
<li><p>SDWebImageCacheMemoryOnly 只缓存到内存中，不缓存到硬盘上</p>
</li>
<li><p>SDWebImageProgressiveDownload 图片会一点一点慢慢显示出来（就像浏览器显示网页上的图片一样）</p>
</li>
<li><p>SDWebImageRefreshCached 将硬盘缓存交给系统自带的NSURLCache去处理，当同一个URL对应的图片经常更改时可以用这种策略</p>
</li>
<li><p>NSURLCache自带的cache机制，每次都要把缓存的row data再转化为UIImage，带来了数据处理和内存方面的更多操作。<br><strong>6，查询缓存和硬盘中是否有图片</strong></p>
<ul>
<li><p>(BOOL)cachedImageExistsForURL:(NSURL *)url {</p>
<p>//调用上面的方法取到image的url对应的key<br>NSString *key = [self cacheKeyForURL:url];</p>
<p>//首先检测内存缓存中时候存在这张图片,如果已有直接返回yes<br> if ([self.imageCache imageFromMemoryCacheForKey:key] != nil) return YES;</p>
<p>//如果内存缓存里面没有这张图片,那么就调用diskImageExistsWithKey这个方法去硬盘找<br>return [self.imageCache diskImageExistsWithKey:key];<br>}</p>
<p>// 检测硬盘里是否缓存了图片</p>
</li>
<li><p>(BOOL)diskImageExistsForURL:(NSURL <em>)url {<br>NSString </em>key = [self cacheKeyForURL:url];<br>return [self.imageCache diskImageExistsWithKey:key];<br>}<br><strong>7，SDWebImageManager的核心算法</strong></p>
</li>
<li><p>(id <sdwebimageoperation>)downloadImageWithURL:(NSURL *)url</sdwebimageoperation></p>
<pre><code>  options:(SDWebImageOptions)options
 progress:(SDWebImageDownloaderProgressBlock)progressBlock
completed:(SDWebImageCompletionWithFinishedBlock)completedBlock {
</code></pre><p><strong>block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];
</strong>weak SDWebImageCombinedOperation *weakOperation = operation;</p>
</li>
</ul>
</li>
</ul>
<p>上面，block声明的同时，会把取得block所使用的全部自动变量的值，这些值在block中只有“使用权”而没有“修改权”。–block用于指明当前声明的变量在被block捕获之后，可以再block中改变变量的值，<strong>block提供了变量的修改权，但是它不能避免循环引用，需要我们在block内部要退出的时候手动释放变量。
</strong>weak是所有权修饰符，<strong>weak可以避免循环引用的问题，但是其会导致外部对象释放只会，block内部也访问不到对象的问题，我们可以通过在block内部声明一个</strong>strong来只想weakObj，使它在block内部能够保持，又能避免循环引用。</p>
<pre><code>@synchronized (self.runningOperations) {
    [self.runningOperations removeObject:operation];
}
</code></pre><p>@synchronized是OC中一种方便地创建互斥锁的方式–它可以防止不同线程在同一时间执行区块的代码<br>self.failedURLs是一个NSSet类型的集合,里面存放的都是下载失败的图片的url,failedURLs不是NSArray类型的原因是:<br>在搜索一个个元素的时候NSSet比NSArray效率高,主要是它用到了一个算法hash(散列,哈希) ,比如你要存储A,一个hash算法直接就能找到A应该存储的位置;同样当你要访问A的时候,一个hash过程就能找到A存储的位置,对于NSArray,若想知道A到底在不在数组中,则需要遍历整个数据,显然效率较低了<br>并且NSSet里面不含有重复的元素,同一个下载失败的url只会存在一个</p>
<pre><code>BOOL isFailedUrl = NO;
//创建一个互斥锁防止现有的别的线程修改failedURLs
//判断这个url是否是fail过的,如果url failed过的那么isFailedUrl就是true. 
@synchronized (self.failedURLs) {
    isFailedUrl = [self.failedURLs containsObject:url];
}

//如果url不存在那么直接返回一个block,如果url存在那么继续
//!(options &amp; SDWebImageRetryFailed) 之前就提过一个类似的了,它的意思看这个options是不是和SDWebImageRetryFailed不相同
//如果不相同并且isFailedUrl是true.那么就回调一个error的block
if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    dispatch_main_sync_safe(^{
        NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];
        completedBlock(nil, error, SDImageCacheTypeNone, YES, url);
    });
    return operation;
}
</code></pre><p>总结：- sd_setImageWithURL: placeholderImage: options: progress: completed:这个核心算法完成了这些工作：<br>1，创建了一个组合operation，是一个SDWebImageCombinedOperation对象，这个对象负责下载operation创建和管理同时又缓存功能，是对下载和缓存两个过程的组合。<br>2，先去内存缓存和磁盘中寻找这张图片，这两个功能在imagecache的queryDiskCacheForKey：done：方法中完成，这个方法的返回值即是一个缓存operation，赋值给上面方法operation的cacheOperation属性。在查找缓存的完成回调中，它会根据是否设置了SDWebImageRefreshCached选择和代理是否支持下载决定是否要下载（重点），并对下载过程中遇到的NSURLCache的情况做处理，有下载失败的处理以及下载之后进行缓存，然后查看是否设置了形变选项并调用代理的形变方法进行对图片形变处理。</p>
<h2 id="一步一步解析源码（二）SDWebImageDownloader"><a href="#一步一步解析源码（二）SDWebImageDownloader" class="headerlink" title="一步一步解析源码（二）SDWebImageDownloader"></a>一步一步解析源码（二）SDWebImageDownloader</h2><p>SDWebImageManager中实现下载，是调用下面这个方法。- (id<sdwebimageoperation>)downloadImageWithURL:(NSURL *)url。</sdwebimageoperation></p>
<p>在头文件中，SDWebImageDownloaderOptions的选项主要涉及到下载的优先级，缓存，后台任务执行，cookie处理及证书认证几个方面，在下载操作的时候可以使用组合的选项来完成一些特殊的需求。</p>
<p>先是定义两个常量，后面通知的时候用。</p>
<pre><code>extern NSString *const SDWebImageDownloadStartNotification;
extern NSString *const SDWebImageDownloadStopNotification;
</code></pre><p>全局变量：const NSString * str = @“”; 外部也可以访问。</p>
<p>局部变量：static const NSString * str = @“”;只能文件内访问，外部不能访问。</p>
<p>然后是定义了三个block。</p>
<p>接下来看核心的算法downloadImageWithURL：</p>
<pre><code>  - (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock {
__block SDWebImageDownloaderOperation *operation;
__weak SDWebImageDownloader *wself = self;

[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{
    NSTimeInterval timeoutInterval = wself.downloadTimeout;
    if (timeoutInterval == 0.0) {
        timeoutInterval = 15.0;
    }
</code></pre><p>这个addProgressCallback：</p>
<pre><code>dispatch_barrier_sync(self.barrierQueue, ^{
BOOL first = NO;
if (!self.URLCallbacks[url]) {
    self.URLCallbacks[url] = [NSMutableArray new];
    first = YES;
}
</code></pre><p>这里用到了Dispatch Barrier解决多线程并发读写一个资源发生死锁。dispatch_barrier_sync此函数会等待队列中现有的任务行知完，再执行现有的任务，并且在此方法后添加的任务必须等此任务执行完才能执行。来控制执行顺序。</p>

	
	</div>
  <a type="button" href="/2016/09/16/一行一行解读SDWebImage实现原理/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control">
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>Categories</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/技术文章/">技术文章<span>13</span></a></li>
		
			<li><a href="/categories/设计随想录/">设计随想录<span>1</span></a></li>
		
		</ul>
	</div>

		
			

		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/06/17/多线程之GCD(下篇/"><i class="fa fa-file-o"></i>符号化IOS崩溃日志，解读堆栈信息</a>
      </li>
    
      <li>
        <a href="/2016/10/30/shell打包脚本解读/"><i class="fa fa-file-o"></i>shell自动打包脚本解读</a>
      </li>
    
      <li>
        <a href="/2016/10/30/翻翻小视频录制原理/"><i class="fa fa-file-o"></i>翻翻小视频录制原理</a>
      </li>
    
      <li>
        <a href="/2016/10/16/使用FMDB及CoreData实现多表查询/"><i class="fa fa-file-o"></i>使用FMDB及CoreData实现多表查询</a>
      </li>
    
      <li>
        <a href="/2016/10/15/符号化IOS崩溃日志，解读堆栈信息/"><i class="fa fa-file-o"></i>符号化IOS崩溃日志，解读堆栈信息</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank" ]);"="">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank" ]);"="">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank" ]);"="">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/blackshow" title="My Github account." target="_blank" ]);"="">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2019 John Doe
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
